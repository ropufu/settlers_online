<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Numbers</name>
    </assembly>
    <members>
        <member name="T:PeterO.Numbers.EContext">
            <summary>Contains parameters for controlling the precision,
            rounding, and exponent range of arbitrary-precision numbers. (The
            "E" stands for "extended", and has this prefix to group it with the
            other classes common to this library, particularly EDecimal,
            EFloat, and ERational.).

            <para><b>Thread safety:</b> With one exception,
instances of this class are immutable and are safe to use
among multiple threads.  The one exception involves
the <c>Flags</c> property.  If the context's <c>HasFlags</c>
property (a read-only property)
is <c>true</c>, the <c>Flags</c> property is mutable,
thus making the context mutable.  This class doesn't synchronize
access to such mutable contexts, so applications should provide
their own synchronization if a context with the <c>HasFlags</c>
property set to <c>true</c> will be shared among multiple threads
and at least one of those threads needs to write the <c>Flags</c> property
(which can happen, for example, by passing the context to most
methods of <c>EDecimal</c> such as <c>Add</c>).</para>
            </summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagClamped">
            <summary>Signals that the exponent was adjusted to fit the exponent
            range.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagDivideByZero">
            <summary>Signals a division of a nonzero number by zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagInexact">
            <summary>Signals that the result was rounded to a different
            mathematical value, but as close as possible to the
            original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagInvalid">
            <summary>Signals an invalid operation.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagLostDigits">
            <summary>Signals that an operand was rounded to a different
            mathematical value before an operation.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagOverflow">
            <summary>Signals that the result is non-zero and the exponent is
            higher than the highest exponent allowed.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagRounded">
            <summary>Signals that the result was rounded to fit the precision;
            either the value or the exponent may have changed from the
            original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagSubnormal">
            <summary>Signals that the result's exponent, before rounding,
            is lower than the lowest exponent allowed.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.FlagUnderflow">
            <summary>Signals that the result's exponent, before rounding,
            is lower than the lowest exponent allowed, and the result was
            rounded to a different mathematical value, but as close as possible
            to the original.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Basic">
            <summary>A basic arithmetic context, 9 digits precision, rounding
            mode half-up, unlimited exponent range. The default rounding mode
            is HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.BigDecimalJava">
            <summary>An arithmetic context for Java's BigDecimal format. The
            default rounding mode is HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary128">
            <summary>An arithmetic context for the IEEE-754-2008 binary128
            format, 113 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary16">
            <summary>An arithmetic context for the IEEE-754-2008 binary16
            format, 11 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary32">
            <summary>An arithmetic context for the IEEE-754-2008 binary32
            format, 24 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Binary64">
            <summary>An arithmetic context for the IEEE-754-2008 binary64
            format, 53 bits precision. The default rounding mode is
            HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.CliDecimal">
            <summary>An arithmetic context for the .NET Framework decimal
            format (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ),
            96 bits precision, and a valid exponent range of -28 to 0. The
            default rounding mode is HalfEven. (The <c>"Cli"</c> stands for "Common
            Language Infrastructure", which defined this format as the .NET
            Framework decimal format in version 1, but leaves it unspecified in
            later versions.).</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal128">
            <summary>An arithmetic context for the IEEE-754-2008 decimal128
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal32">
            <summary>An arithmetic context for the IEEE-754-2008 decimal32
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Decimal64">
            <summary>An arithmetic context for the IEEE-754-2008 decimal64
            format. The default rounding mode is HalfEven.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.Unlimited">
            <summary>No specific (theoretical) limit on precision. Rounding
            mode HalfUp.</summary>
        </member>
        <member name="F:PeterO.Numbers.EContext.UnlimitedHalfEven">
            <summary>No specific (theoretical) limit on precision. Rounding
            mode HalfEven.</summary>
        </member>
        <member name="M:PeterO.Numbers.EContext.#ctor(System.Int32,PeterO.Numbers.ERounding,System.Int32,System.Int32,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:PeterO.Numbers.EContext" /> class. <c>HasFlags</c> will
            be set to false.</summary><param name="precision">The maximum number of digits a number can
            have, or 0 for an unlimited number of digits.</param><param name="rounding">The rounding mode to use when a number can't
            fit the given precision.</param><param name="exponentMinSmall">The minimum exponent.</param><param name="exponentMaxSmall">The maximum exponent.</param><param name="clampNormalExponents">Whether to clamp a number's
            significand to the given maximum precision (if it isn't zero) while
            remaining within the exponent range.</param>
        </member>
        <member name="P:PeterO.Numbers.EContext.AdjustExponent">
            <summary>Gets a value indicating whether the EMax and EMin
            properties refer to the number's Exponent property adjusted to the
            number's precision, or just the number's Exponent property. The
            default value is true, meaning that EMax and EMin refer to the
            adjusted exponent. Setting this value to false (using
            WithAdjustExponent) is useful for modeling floating point
            representations with an integer mantissa (significand) and an
            integer exponent, such as Java's BigDecimal.</summary><value><c>true</c> if the EMax and EMin properties refer to the
            number's Exponent property adjusted to the number's
            precision, or false if they refer to just the number's
            Exponent property.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.ClampNormalExponents">
            <summary>Gets a value indicating whether a converted number's
            Exponent property will not be higher than EMax + 1 - Precision. If
            a number's exponent is higher than that value, but not high
            enough to cause overflow, the exponent is clamped to that value and
            enough zeros are added to the number's mantissa (significand)
            to account for the adjustment. If HasExponentRange is false, this
            value is always false.</summary><value>If true, a converted number's Exponent property will
            not be higher than EMax + 1 - Precision.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.EMax">
            <summary>Gets the highest exponent possible when a converted number
            is expressed in scientific notation with one digit before the radix
            point. For example, with a precision of 3 and an EMax of 100, the
            maximum value possible is 9.99E + 100. (This is not the same as the
            highest possible Exponent property.) If HasExponentRange is false,
            this value will be 0.</summary><value>The highest exponent possible when a converted number is
            expressed in scientific notation with one digit before the decimal
            point. For example, with a precision of 3 and an EMax of 100, the
            maximum value possible is 9.99E + 100. (This is not the same as the
            highest possible Exponent property.) If HasExponentRange is false,
            this value will be 0.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.EMin">
            <summary>Gets the lowest exponent possible when a converted number
            is expressed in scientific notation with one digit before the radix
            point. For example, with a precision of 3 and an EMin of -100, the
            next value that comes after 0 is 0.001E-100. (If AdjustExponent is
            false, this property specifies the lowest possible Exponent
            property instead.) If HasExponentRange is false, this value will be
            0.</summary><value>The lowest exponent possible when a converted number is
            expressed in scientific notation with one digit before the decimal
            point.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Flags">
            <summary>Gets or sets the flags that are set from converting
            numbers according to this arithmetic context. If <c>HasFlags</c> is
            false, this value will be 0. This value is a combination of bit
            fields. To retrieve a particular flag, use the AND operation on the
            return value of this method. For example: <c>(this.Flags &amp;
            EContext.FlagInexact) != 0</c> returns <c>true</c> if the Inexact
            flag is set.</summary><value>The flags that are set from converting numbers according to
            this arithmetic context. If. <c>HasFlags</c> is false, this value
            will be 0.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasExponentRange">
            <summary>Gets a value indicating whether this context defines a
            minimum and maximum exponent. If false, converted exponents can
            have any exponent and operations can't cause overflow or
            underflow.</summary><value><c>true</c> if this context defines a minimum and maximum
            exponent; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasFlags">
            <summary>Gets a value indicating whether this context has a mutable
            Flags field.</summary><value><c>true</c> if this context has a mutable Flags field; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.HasMaxPrecision">
            <summary>Gets a value indicating whether this context defines a
            maximum precision.</summary><value><c>true</c> if this context defines a maximum precision; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.IsPrecisionInBits">
            <summary>Gets a value indicating whether this context's Precision
            property is in bits, rather than digits. The default is
            false.</summary><value><c>true</c> if this context's Precision property is in
            bits, rather than digits; otherwise, <c>false</c>. The default
            is false.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.IsSimplified">
            <summary>Gets a value indicating whether to use a "simplified"
            arithmetic. In the simplified arithmetic, infinity, not-a-number,
            and subnormal numbers are not allowed, and negative zero is treated
            the same as positive zero. For further details, see
            <a href="http://speleotrove.com/decimal/dax3274.html">
            <c>http://speleotrove.com/decimal/dax3274.html</c></a></summary><value><c>true</c> if a "simplified" arithmetic will be
            used; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Precision">
            <summary>Gets the maximum length of a converted number in digits,
            ignoring the radix point and exponent. For example, if precision is
            3, a converted number's mantissa (significand) can range from
            0 to 999 (up to three digits long). If 0, converted numbers can
            have any precision.</summary><value>The maximum length of a converted number in digits, ignoring
            the radix point and exponent.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Rounding">
            <summary>Gets the desired rounding mode when converting numbers
            that can't be represented in the given precision and exponent
            range.</summary><value>The desired rounding mode when converting numbers that
            can't be represented in the given precision and exponent
            range.</value>
        </member>
        <member name="P:PeterO.Numbers.EContext.Traps">
            <summary>Gets the traps that are set for each flag in the context.
            Whenever a flag is signaled, even if <c>HasFlags</c> is false, and
            the flag's trap is enabled, the operation will throw a
            TrapException.
            <para>For example, if Traps equals <c>FlagInexact</c> and
            FlagSubnormal, a TrapException will be thrown if an operation's
            return value is not the same as the exact result (FlagInexact) or
            if the return value's exponent is lower than the lowest allowed
            (FlagSubnormal).</para></summary><value>The traps that are set for each flag in the context.</value>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForPrecision(System.Int32)">
            <summary>Creates a new arithmetic context using the given maximum
            number of digits, an unlimited exponent range, and the HalfUp
            rounding mode.</summary><param name="precision">Maximum number of digits
            (precision).</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForPrecisionAndRounding(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Creates a new EContext object initialized with an
            unlimited exponent range, and the given rounding mode and maximum
            precision.</summary><param name="precision">Maximum number of digits
            (precision).</param><param name="rounding">The parameter <paramref name="rounding" /> is an ERounding object.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ForRounding(PeterO.Numbers.ERounding)">
            <summary>Creates a new EContext object initialized with an
            unlimited precision, an unlimited exponent range, and the given
            rounding mode.</summary><param name="rounding">The rounding mode for the new precision
            context.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.Copy">
            <summary>Initializes a new EContext that is a copy of another
            EContext.</summary><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.ExponentWithinRange(PeterO.Numbers.EInteger)">
            <summary>Determines whether a number can have the given Exponent
            property under this arithmetic context.</summary><param name="exponent">An arbitrary-precision integer indicating
            the desired exponent.</param><returns><c>true</c> if a number can have the given Exponent
            property under this arithmetic context; otherwise, <c>false</c>. If this
            context allows unlimited precision, returns true for the exponent
            EMax and any exponent less than EMax.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="exponent" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.ToString">
            <summary>Gets a string representation of this object. Note that the
            format is not intended to be parsed and may change at any
            time.</summary><returns>A string representation of this object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithAdjustExponent(System.Boolean)">
            <summary>Copies this EContext and sets the copy's "AdjustExponent"
            property to the given value.</summary><param name="adjustExponent">The new value of the "AdjustExponent"
            property for the copy.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBigExponentRange(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Copies this arithmetic context and sets the copy's
            exponent range.</summary><param name="exponentMin">Desired minimum exponent (EMin).</param><param name="exponentMax">Desired maximum exponent (EMax).</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="exponentMin" /> is null.</exception><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="exponentMax" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBigPrecision(PeterO.Numbers.EInteger)">
            <summary>Copies this EContext and gives it a particular precision
            value.</summary><param name="bigintPrecision">Desired precision. 0 means unlimited
            precision.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintPrecision" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithBlankFlags">
            <summary>Copies this EContext with <c>HasFlags</c> set to true and
            a Flags value of 0.</summary><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithExponentClamp(System.Boolean)">
            <summary>Copies this arithmetic context and sets the copy's
            "ClampNormalExponents" flag to the given value.</summary><param name="clamp">The desired value of the "ClampNormalExponents" flag.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithExponentRange(System.Int32,System.Int32)">
            <summary>Copies this arithmetic context and sets the copy's
            exponent range.</summary><param name="exponentMinSmall">Desired minimum exponent
            (EMin).</param><param name="exponentMaxSmall">Desired maximum exponent
            (EMax).</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithNoFlags">
            <summary>Copies this EContext with <c>HasFlags</c> set to false and
            a Flags value of 0.</summary><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithPrecision(System.Int32)">
            <summary>Copies this EContext and gives it a particular precision
            value.</summary><param name="precision">Desired precision. 0 means unlimited
            precision.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithPrecisionInBits(System.Boolean)">
            <summary>Copies this EContext and sets the copy's
            "IsPrecisionInBits" property to the given value.</summary><param name="isPrecisionBits">The new value of the
            "IsPrecisionInBits" property for the copy.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithRounding(PeterO.Numbers.ERounding)">
            <summary>Copies this EContext with the specified rounding
            mode.</summary><param name="rounding">Desired value of the Rounding
            property.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithSimplified(System.Boolean)">
            <summary>Copies this EContext and sets the copy's "IsSimplified"
            property to the given value.</summary><param name="simplified">Desired value of the IsSimplified property.</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithTraps(System.Int32)">
            <summary>Copies this EContext with Traps set to the given
            value.</summary><param name="traps">Flags representing the traps to enable. See the
            property "Traps".</param><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="M:PeterO.Numbers.EContext.WithUnlimitedExponents">
            <summary>Copies this EContext with an unlimited exponent
            range.</summary><returns>A context object for arbitrary-precision arithmetic
            settings.</returns>
        </member>
        <member name="T:PeterO.Numbers.EDecimal">
            <summary>
            Represents an arbitrary-precision decimal
            floating-point number. (The "E" stands for "extended",
            meaning that instances of this class can be values
            other than numbers proper, such as infinity and
            not-a-number.)
            <para><b>About decimal arithmetic</b>
             </para>
            <para>Decimal (base-10) arithmetic, such as that provided by this
            class, is appropriate for calculations involving such real-world
            data as prices and other sums of money, tax rates, and
            measurements. These calculations often involve multiplying or
            dividing one decimal with another decimal, or performing other
            operations on decimal numbers. Many of these calculations also rely
            on rounding behavior in which the result after rounding is a
            decimal number (for example, multiplying a price by a premium rate,
            then rounding, should result in a decimal amount of money).</para>
            <para>On the other hand, most implementations of <c>float</c>
             and
            <c>double</c>
             , including in C# and Java, store numbers in a binary
            (base-2) floating-point format and use binary floating-point
            arithmetic. Many decimal numbers can't be represented exactly in
            binary floating-point format (regardless of its length). Applying
            binary arithmetic to numbers intended to be decimals can sometimes
            lead to unintuitive results, as is shown in the description for the
            FromDouble() method of this class.</para>
            <para><b>About EDecimal instances</b>
             </para>
            <para>Each instance of this class consists of an integer mantissa
            (significand) and an integer exponent, both arbitrary-precision.
            The value of the number equals mantissa (significand) *
            10^exponent.</para>
            <para>The mantissa (significand) is the value of the digits that
            make up a number, ignoring the decimal point and exponent. For
            example, in the number 2356.78, the mantissa (significand) is
            235678. The exponent is where the "floating" decimal point of the
            number is located. A positive exponent means "move it to the
            right", and a negative exponent means "move it to the left." In the
            example 2, 356.78, the exponent is -2, since it has 2 decimal
            places and the decimal point is "moved to the left by 2."
            Therefore, in the arbitrary-precision decimal representation, this
            number would be stored as 235678 * 10^-2.</para>
            <para>The mantissa (significand) and exponent format preserves
            trailing zeros in the number's value. This may give rise to
            multiple ways to store the same value. For example, 1.00 and 1
            would be stored differently, even though they have the same value.
            In the first case, 100 * 10^-2 (100 with decimal point moved left
            by 2), and in the second case, 1 * 10^0 (1 with decimal point moved
            0).</para>
            <para>This class also supports values for negative zero,
            not-a-number (NaN) values, and infinity. <b>Negative zero</b>
             is
            generally used when a negative number is rounded to 0; it has the
            same mathematical value as positive zero. <b>Infinity</b>
             is
            generally used when a non-zero number is divided by zero, or when a
            very high or very low number can't be represented in a given
            exponent range. <b>Not-a-number</b>
             is generally used to signal
            errors.</para>
            <para>This class implements the General Decimal Arithmetic
            Specification version 1.70 (except part of chapter 6):
            <c>http://speleotrove.com/decimal/decarith.html</c>
             </para>
            <para><b>Errors and Exceptions</b>
             </para>
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless noted
            otherwise.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless noted otherwise. Invalid operations
            will also return a quiet NaN, as stated in the individual
            methods.</para>
            <para>Unless noted otherwise,passing a null arbitrary-precision
            decimal argument to any method here will throw an exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the flag's trap is enabled in the arithmetic context
            (see EContext's Traps property).</para>
            <para>If an operation requires creating an intermediate value that
            might be too big to fit in memory (or might require more than 2
            gigabytes of memory to store -- due to the current use of a 32-bit
            integer internally as a length), the operation may signal an
            invalid-operation flag and return not-a-number (NaN). In certain
            rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Serialization</b>
             </para>
            <para>An arbitrary-precision decimal value can be serialized
            (converted to a stable format) in one of the following ways:</para>
            <list><item>By calling the toString() method, which will always
            return distinct strings for distinct arbitrary-precision decimal
            values.</item>
             <item>By calling the UnsignedMantissa, Exponent, and
            IsNegative properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision decimal value.</item>
            </list>
            <para><b>Thread safety</b>
             </para>
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which might only check if each
            side of the operator is the same instance).</para>
            <para><b>Comparison considerations</b>
             </para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method. The CompareTo method compares the
            mathematical values of the two instances passed to it (and
            considers two different NaN values as equal), while two instances
            with the same mathematical value, but different exponents, will be
            considered unequal under the Equals method.</para>
            <para><b>Forms of numbers</b>
             </para>
            <para>There are several other types of numbers that are mentioned
            in this class and elsewhere in this documentation. For reference,
            they are specified here.</para>
            <para><b>Unsigned integer</b>
             : An integer that's always 0 or
            greater, with the following maximum values:</para>
            <list><item>8-bit unsigned integer, or <i>byte</i>
             : 255.</item>
            <item>16-bit unsigned integer: 65535.</item>
             <item>32-bit unsigned
            integer: (2 <sup>32</sup> -1).</item>
             <item>64-bit unsigned
            integer: (2 <sup>64</sup> -1).</item>
             </list>
            <para><b>Signed integer</b>
             : An integer in <i>two's complement
            form</i>
             , with the following ranges:</para>
            <list><item>8-bit signed integer: -128 to 127.</item>
             <item>16-bit
            signed integer: -32768 to 32767.</item>
             <item>32-bit signed
            integer: -2 <sup>31</sup>
             to (2 <sup>31</sup>
             - 1).</item>
            <item>64-bit signed integer: -2 <sup>63</sup>
             to (2 <sup>63</sup>
             -  1).</item>
             </list>
            <para><b>Two's complement form</b>
             : In <i>two' s-complement
            form</i>
             , nonnegative numbers have the highest (most significant) bit set to zero, and negative numbers have that bit (and all bits beyond) set to one, and a negative number is stored in such form by decreasing its absolute value by 1 and swapping the bits of the resulting number.</para>
            <para><b>64-bit floating-point number</b>
             : A 64-bit binary
            floating-point number, in the form <i>significand</i>
             * 2
            <sup><i>exponent</i>
             </sup>
             . The significand is 53 bits long
            (Precision) and the exponent ranges from -1074 (EMin) to 971
            (EMax). The number is stored in the following format (commonly
            called the IEEE 754 format):</para>
            <code>|C|BBB...BBB|AAAAAA...AAAAAA|</code>
            <list><item>A. Low 52 bits (Precision minus 1 bits): Lowest bits of
            the significand.</item>
             <item>B. Next 11 bits: Exponent area:
            <list><item>If all bits are ones, this value is infinity if all
            bits in area A are zeros, or not-a-number (NaN) otherwise.</item>
            <item>If all bits are zeros, this is a subnormal number. The
            exponent is EMin and the highest bit of the significand is
            zero.</item>
             <item>If any other number, the exponent is this value
            reduced by 1, then raised by EMin, and the highest bit of the
            significand is one.</item>
             </list>
             </item>
             <item>C. Highest bit: If
            one, this is a negative number.</item>
             </list>
            <para>The elements described above are in the same order as the
            order of each bit of each element, that is, either most significant
            first or least significant first.</para>
            <para><b>32-bit binary floating-point number</b>
             : A 32-bit binary number
            which is stored similarly to a <i>64-bit floating-point number</i>
            , except that:</para>
            <list><item>Precision is 24 bits.</item>
             <item>EMin is -149.</item>
            <item>EMax is 104.</item>
             <item>A. The low 23 bits (Precision minus
            1 bits) are the lowest bits of the significand.</item>
             <item>B. The
            next 8 bits are the exponent area.</item>
             <item>C. If the highest
            bit is one, this is a negative number.</item>
             </list>
            <para><b>.NET Framework decimal</b> : A 128-bit decimal
            floating-point number, in the form <i>significand</i> * 10 <sup>-
            <i>scale</i>
             </sup>
             , where the scale ranges from 0 to 28. The
            number is stored in the following format:</para>
            <list><item>Low 96 bits are the significand, as a 96-bit unsigned
            integer (all 96-bit values are allowed, up to (2 <sup>96</sup>
            -1)).</item>
             <item>Next 16 bits are unused.</item>
             <item>Next 8
            bits are the scale, stored as an 8-bit unsigned integer.</item>
            <item>Next 7 bits are unused.</item>
             <item>If the highest bit is
            one, it's a negative number.</item>
             </list>
            <para>The elements described above are in the same order as the
            order of each bit of each element, that is, either most significant
            first or least significant first.</para>
            </summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.NegativeZero">
            <summary>Represents the number negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.One">
            <summary>Represents the number 1.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.SignalingNaN">
            <summary>A not-a-number value that signals an invalid operation
            flag when it's passed as an argument to any arithmetic
            operation in arbitrary-precision decimal.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.Ten">
            <summary>Represents the number 10.</summary>
        </member>
        <member name="F:PeterO.Numbers.EDecimal.Zero">
            <summary>Represents the number 0.</summary>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Exponent">
            <summary>Gets this object's exponent. This object's value
            will be an integer if the exponent is positive or zero.</summary><value>This object's exponent. This object's value will
            be an integer if the exponent is positive or zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary><value><c>true</c> if this object is finite (not infinity or
            not-a-number (NaN)); otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsNegative">
            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary><value><c>true</c> if this object is negative, including negative
            zero; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.IsZero">
            <summary>Gets a value indicating whether this object's value
            equals 0.</summary><value><c>true</c> if this object's value equals 0; otherwise,
            . <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Mantissa">
            <summary>Gets this object's unscaled value.</summary><value>This object's unscaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.Sign">
            <summary>Gets this value's sign: -1 if negative; 1 if
            positive; 0 if zero.</summary><value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EDecimal.UnsignedMantissa">
            <summary>Gets the absolute value of this object's unscaled
            value.</summary><value>The absolute value of this object's unscaled
            value.</value>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(System.Int32,System.Int32)">
            <summary>Creates a number with the value
            <c>exponent*10^mantissa</c></summary><param name="mantissaSmall">Desired value for the mantissa.</param><param name="exponentSmall">Desired value for the exponent.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates a number with the value
            <c>exponent*10^mantissa</c></summary><param name="mantissa">Desired value for the mantissa.</param><param name="exponent">Desired value for the exponent.</param><returns>An arbitrary-precision decimal number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="mantissa" /> or <paramref name="exponent" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><returns>A quiet not-a-number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null or is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">
            <summary>Creates a not-a-number arbitrary-precision decimal
            number.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><param name="signaling">Whether the return value will be signaling
            (true) or quiet (false).</param><param name="negative">Whether the return value is
            negative.</param><param name="ctx">An arithmetic context to control the precision
            (in decimal digits) of the diagnostic information. The rounding and
            exponent range of this context will be ignored. Can be null. The
            only flag that can be signaled in this context is FlagInvalid,
            which happens if diagnostic information needs to be truncated and
            too much memory is required to do so.</param><returns>An arbitrary-precision decimal number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null or is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromDouble(System.Double)">
            <summary>Creates a decimal number from a 64-bit binary
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string first.
            Remember, though, that the exact value of a 64-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number (for example, calling
            <c>ExtendedDecimal.FromDouble(0.1f)</c> ), since not all decimal
            numbers can be converted to exact binary numbers (in the example
            given, the resulting arbitrary-precision decimal will be the value
            of the closest "double" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal number, use
            FromString instead in most cases (for example:
            <c>ExtendedDecimal.FromString("0.1")</c> ).</summary><param name="dbl">The parameter <paramref name="dbl" /> is a 64-bit floating-point number.</param><returns>A decimal number with the same value as <paramref name="dbl" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision decimal.</summary><param name="bigint">An arbitrary-precision integer.</param><returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigint" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromExtendedFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary floating-point
            number to an arbitrary
            precision decimal.</summary><param name="ef">An arbitrary-precision binary floating-point
            number.</param><returns>An arbitrary-precision decimal number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="ef" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromEFloat(PeterO.Numbers.EFloat)">
            <summary>Creates a decimal number from an arbitrary-precision
            binary floating-point number.</summary><param name="bigfloat">An arbitrary-precision binary floating-point
            number.</param><returns>An arbitrary-precision decimal number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigfloat" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt32(System.Int32)">
            <summary>Creates a decimal number from a 32-bit signed
            integer.</summary><param name="valueSmaller">The parameter <paramref name="valueSmaller" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt64(System.Int64)">
            <summary>Creates a decimal number from a 64-bit signed
            integer.</summary><param name="valueSmall">The parameter <paramref name="valueSmall" /> is a 64-bit signed integer.</param><returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromSingle(System.Single)">
            <summary>Creates a decimal number from a 32-bit binary
            floating-point number. This method computes the exact value of the
            floating point number, not an approximation, as is often the case
            by converting the floating point number to a string first.
            Remember, though, that the exact value of a 32-bit binary
            floating-point number is not always the value that results when
            passing a literal decimal number (for example, calling
            <c>ExtendedDecimal.FromSingle(0.1f)</c> ), since not all decimal
            numbers can be converted to exact binary numbers (in the example
            given, the resulting arbitrary-precision decimal will be the the
            value of the closest "float" to 0.1, not 0.1 exactly). To create an
            arbitrary-precision decimal number from a decimal number, use
            FromString instead in most cases (for example:
            <c>ExtendedDecimal.FromString("0.1")</c> ).</summary><param name="flt">The parameter <paramref name="flt" /> is a 32-bit binary floating-point number.</param><returns>A decimal number with the same value as <paramref name="flt" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String)">
            <summary>Creates a decimal number from a text string that
            represents a number. See <c>FromString(String, int, int,
            EContext)</c> for more information.</summary><param name="str">A string that represents a number.</param><returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,PeterO.Numbers.EContext)">
            <summary>Creates a decimal number from a text string that
            represents a number. See <c>FromString(String, int, int,
            EContext)</c> for more information.</summary><param name="str">A string that represents a number.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32)">
            <summary>Creates a decimal number from a text string that
            represents a number. See <c>FromString(String, int, int,
            EContext)</c> for more information.</summary><param name="str">A string that represents a number.</param><param name="offset">A zero-based index showing where the desired
            portion of <paramref name="str" /> begins.</param><param name="length">The length, in code units, of the desired
            portion of <paramref name="str" /> (but not more than <paramref name="str" /> 's length).</param><returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>
            <para>Creates a decimal number from a text string that represents a
            number.</para>
            <para>The format of the string generally consists of:</para>
            <list type="">
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if the minus sign, the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            after the first digit and before the last digit.</item>
            <item>Optionally, "E"/"e" followed by an optional (positive
            exponent) or "-" (negative exponent) and followed by one or more
            digits specifying the exponent.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits,
            or signaling NaN ("sNaN" /"-sNaN") followed by any number of
            digits, all in any combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is
            not allowed to contain white space characters, including
            spaces.</para></summary><param name="str">A text string, a portion of which represents a
            number.</param><param name="offset">A zero-based index that identifies the start
            of the number.</param><param name="length">The length of the number within the
            string.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two decimal
            numbers.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The larger value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the greater value between two decimal
            numbers.</summary><param name="first">An arbitrary-precision decimal number.</param><param name="second">Another arbitrary-precision decimal
            number.</param><returns>The larger value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two decimal
            numbers.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The smaller value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the lesser value between two decimal
            numbers.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>The smaller value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.PI(PeterO.Numbers.EContext)">
            <summary>Finds the constant π, the circumference of a circle
            divided by its diameter.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as π can never be
            represented exactly.</i>.</param><returns>The constant π rounded to the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Abs">
            <summary>Finds the absolute value of this object (if it's
            negative, it becomes positive).</summary><returns>An arbitrary-precision decimal number. Returns signaling
            NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CopySign(PeterO.Numbers.EDecimal)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another
            number.</summary><param name="other">A number whose sign will be copied.</param><returns>An arbitrary-precision decimal number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="other" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Abs(PeterO.Numbers.EContext)">
            <summary>Finds the absolute value of this object (if it's
            negative, it becomes positive).</summary><param name="context">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The absolute value of this object. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal)">
            <summary>Adds this object and another decimal number and returns
            the result.</summary><param name="otherValue">An arbitrary-precision decimal
            number.</param><returns>The sum of the two objects.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the sum of this object and another object. The
            result's exponent is set to the lower of the exponents of the
            two operands.</summary><param name="otherValue">The number to add to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The sum of thisValue and the other object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareTo(PeterO.Numbers.EDecimal)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary><param name="other">An arbitrary-precision decimal number.</param><returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name="other" /> is null, or 0 if both
            values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToBinary(PeterO.Numbers.EFloat)">
            <summary>Compares an arbitrary-precision binary float with this
            instance.</summary><param name="other">The other object to compare. Can be
            null.</param><returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is greater.
            Returns 0 if both values are NaN (even signaling NaN) and 1 if this
            value is NaN (even signaling NaN) and the other isn't, or if the
            other value is null.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToSignal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary><param name="other">An arbitrary-precision decimal number.</param><param name="ctx">An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param><returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary><param name="other">An arbitrary-precision decimal number to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary><param name="other">An arbitrary-precision decimal number to
            compare with this one.</param><param name="ctx">An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater. Does not signal flags if either value is signaling
            NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary><param name="other">An arbitrary-precision decimal number to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.CompareToWithContext(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary><param name="other">An arbitrary-precision decimal number.</param><param name="ctx">An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param><returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal)">
            <summary>Divides this object by another decimal number and returns
            the result. When possible, the result will be exact.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating
            decimal expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision decimal number by another
            arbitrary-precision decimal number. The preferred exponent for the
            result is this object's exponent minus the divisor's
            exponent.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0; or, either <paramref name="ctx" />
            is null or <paramref name="ctx" /> 's precision is 0, and the result
            would have a nonterminating decimal expansion; or, the rounding
            mode is ERounding.None and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentSmall">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><param name="ctx">An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentInt">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><param name="ctx">An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentSmall">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentInt">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="exponent">The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point (so
            a negative number means the number of decimal places to round to).
            A positive number places the cutoff point to the left of the usual
            decimal point.</param><param name="ctx">An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result, using the half-even rounding
            mode.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="exponent">The desired exponent. A negative number
            places the cutoff point to the right of the usual decimal point (so
            a negative number means the number of decimal places to round to).
            A positive number places the cutoff point to the left of the usual
            decimal point.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 64-bit signed integer) to the
            result, using the half-even rounding mode.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentSmall">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent (expressed as a 32-bit signed integer) to the
            result, using the half-even rounding mode.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponentInt">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision decimal numbers, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><param name="desiredExponent">The desired exponent. A negative
            number places the cutoff point to the right of the usual decimal
            point (so a negative number means the number of decimal places to
            round to). A positive number places the cutoff point to the left of
            the usual decimal point.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Divides two arbitrary-precision decimal numbers, and
            returns the integer part of the result, rounded down, with the
            preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary><param name="divisor">An arbitrary-precision decimal number to
            divide by.</param><returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result (which is initially rounded down), with
            the preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the integer part of the
            result. Flags will be set on the given context only if the
            context's <c>HasFlags</c> is true and the integer part of the
            result doesn't fit the precision and exponent range without
            rounding. Can be null, in which the precision is unlimited and no
            additional rounding, other than the rounding down to an integer
            after division, is needed.</param><returns>The integer part of the quotient of the two objects.
            Signals FlagInvalid and returns not-a-number (NaN) if the return
            value would overflow the exponent range. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToIntegerZeroScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If <c>HasFlags</c> of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited.</param><returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DivideToSameExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.ERounding)">
            <summary>Divides this object by another decimal number and returns
            a result with the same exponent as this object (the
            dividend).</summary><param name="divisor">The number to divide by.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Equals(PeterO.Numbers.EDecimal)">
            <summary>Determines whether this object's mantissa
            (significand), exponent, and properties are equal to those of another
            object. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="other">An arbitrary-precision decimal number.</param><returns><c>true</c> if this object's mantissa (significand) and
            exponent are equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Equals(System.Object)">
            <summary>Determines whether this object's mantissa
            (significand), exponent, and properties are equal to those of another
            object and that other object is an arbitrary-precision decimal number. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="obj">The parameter <paramref name="obj" /> is an arbitrary object.</param><returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Exp(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Decimal
            Arithmetic Specification, any rounding mode is allowed.).</param><returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given precision.
            Signals FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.GetHashCode">
            <summary>Calculates this object's hash code.  No application or process IDs are used in the hash code calculation.</summary><returns>This object's hash code.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsInfinity">
            <summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary><returns><c>true</c> if this object is positive or negative
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsNaN">
            <summary>Gets a value indicating whether this object is not a
            number (NaN).</summary><returns><c>true</c> if this object is not a number (NaN); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary><returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary><returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsQuietNaN">
            <summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary><returns><c>true</c> if this object is a quiet not-a-number value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.IsSignalingNaN">
            <summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary><returns><c>true</c> if this object is a signaling not-a-number
            value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Log(PeterO.Numbers.EContext)">
            <summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Decimal Arithmetic
            Specification, any rounding mode is allowed.).</param><returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null or the precision is
            unlimited (the context's Precision property is 0). Signals no flags
            and returns negative infinity if this object's value is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Log10(PeterO.Numbers.EContext)">
            <summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Decimal Arithmetic
            Specification, any rounding mode is allowed.).</param><returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary><param name="places">The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param><returns>A number whose exponent is decreased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary><param name="places">The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is decreased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary><param name="bigPlaces">The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param><returns>A number whose exponent is decreased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the left.</summary><param name="bigPlaces">The number of decimal places to move the
            decimal point to the left. If this number is negative, instead
            moves the decimal point to the right by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is decreased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary><param name="places">The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param><returns>A number whose exponent is increased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary><param name="places">The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is increased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary><param name="bigPlaces">The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            decimal point moved to the right.</summary><param name="bigPlaces">The number of decimal places to move the
            decimal point to the right. If this number is negative, instead
            moves the decimal point to the left by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal)">
            <summary>Multiplies two decimal numbers. The resulting exponent
            will be the sum of the exponents of the two decimal
            numbers.</summary><param name="otherValue">Another decimal number.</param><returns>The product of the two decimal numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies two decimal numbers. The resulting scale will
            be the sum of the scales of the two decimal numbers. The
            result's sign is positive if both operands have the same sign,
            and negative if they have different signs.</summary><param name="op">Another decimal number.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The product of the two decimal numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Multiplies by one decimal number, and then adds another
            decimal number.</summary><param name="multiplicand">The value to multiply.</param><param name="augend">The value to add.</param><returns>The result this * <paramref name="multiplicand" /> +
            <paramref name="augend" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then adds another
            value.</summary><param name="op">The value to multiply.</param><param name="augend">The value to add.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and adding.</param><returns>The result thisValue * multiplicand + augend.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.MultiplyAndSubtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then subtracts another
            value.</summary><param name="op">The value to multiply.</param><param name="subtrahend">The value to subtract.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and subtracting.</param><returns>The result thisValue * multiplicand -
            subtrahend.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="op" /> or <paramref name="subtrahend" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Negate">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary><returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Negate(PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but with the sign reversed.</summary><param name="context">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns positive zero. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextMinus(PeterO.Numbers.EContext)">
            <summary>Finds the largest value that's smaller than the given
            value.</summary><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null, the precision is 0, or
            <paramref name="ctx" /> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextPlus(PeterO.Numbers.EContext)">
            <summary>Finds the smallest value that's greater than the
            given value.</summary><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the smallest value that's greater than the given
            value.Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null, the precision is 0, or
            <paramref name="ctx" /> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.NextToward(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the next value that is closer to the other
            object's value than this object's value. Returns a copy
            of this value with the same sign as the other value if both values
            are equal.</summary><param name="otherValue">An arbitrary-precision decimal number that
            the return value will approach.</param><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the next value that is closer to the other object'
            s value than this object's value. Signals FlagInvalid and returns
            NaN if the parameter <paramref name="ctx" /> is null, the precision
            is 0, or <paramref name="ctx" /> has an unlimited exponent
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Plus(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision,
            using the given rounding mode and range of exponent, and also
            converts negative zero to positive zero.</summary><param name="ctx">A context for controlling the precision, rounding
            mode, and exponent range. Can be null, in which case the precision
            is unlimited and rounding isn't needed.</param><returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name="ctx" /> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponent">An arbitrary-precision decimal number
            expressing the exponent to raise this object's value to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null or the precision is
            unlimited (the context's Precision property is 0), and the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(System.Int32,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponentSmall">The exponent to raise this object's
            value to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Pow(System.Int32)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponentSmall">The exponent to raise this object's
            value to.</param><returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Precision">
            <summary>Finds the number of digits in this number's mantissa
            (significand). Returns 1 if this value is 0, and 0 if this value is
            infinity or not-a-number (NaN).</summary><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>
            Returns a decimal number with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point decimal arithmetic, in which each decimal number has a
            fixed number of digits after the decimal point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the decimal point:</para>
            <code>
            // After performing arithmetic operations, adjust
            // the number to 5
            // digits after the decimal point
            number = number.Quantize(
            EInteger.FromInt32(-5),  // five digits after the decimal point
            EContext.ForPrecision(25)  // 25-digit precision);
            </code>
            <para>A fixed-point decimal arithmetic in which no digits come
            after the decimal point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary><param name="desiredExponent">The desired exponent for the result.
            The exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if this object is infinity, if the rounded
            result can't fit the given precision, or if the context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns a decimal number with the same value as this one
            but a new exponent.
            <para><b>Remark:</b> This method can be used to implement
            fixed-point decimal arithmetic, in which a fixed number of digits
            come after the decimal point. A fixed-point decimal arithmetic in
            which no digits come after the decimal point (a desired exponent of
            0) is considered an "integer arithmetic".</para></summary><param name="desiredExponentInt">The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="rounding">A rounding mode to use in case the result
            needs to be rounded to fit the given exponent.</param><returns>A decimal number with the same value as this object but
            with the exponent changed. Returns not-a-number (NaN) if this
            object is infinity, or if the rounding mode is ERounding.None and
            the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.EContext)">
            <summary>
            Returns a decimal number with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point decimal arithmetic, in which each decimal number has a
            fixed number of digits after the decimal point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the decimal point:</para>
            <code>
            // After performing arithmetic operations, adjust  // the number to 5
            digits after the decimal point number = number.Quantize(-5,  // five
            digits after the decimal point EContext.ForPrecision(25)  // 25-digit
            precision);
            </code>
            <para>A fixed-point decimal arithmetic in which no digits come
            after the decimal point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary><param name="desiredExponentInt">The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if this object is infinity, if the rounded
            result can't fit the given precision, or if the context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but with the same exponent as another decimal number.
            <para>Note that this is not always the same as rounding to a given
            number of decimal places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            decimal places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point decimal arithmetic, in which a fixed number of digits
            come after the decimal point. A fixed-point decimal arithmetic in
            which no digits come after the decimal point (a desired exponent of
            0) is considered an "integer arithmetic".</para></summary><param name="otherValue">A decimal number containing the desired
            exponent of the result. The mantissa (significand) is ignored. The
            exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which eliminates lower-order places from the number. For example, -3 means round to the sixteenth (10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number to an integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A decimal number with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if the result can't fit the given precision
            without rounding, or if the arithmetic context defines an exponent
            range and the given exponent is outside that range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Reduce(PeterO.Numbers.EContext)">
            <summary>Removes trailing zeros from this object's mantissa
            (significand). For example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the mantissa
            (significand).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Remainder(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the remainder that results when dividing two
            arbitrary-precision decimal numbers. The remainder is the value
            that remains when the absolute value of this object is divided by
            the absolute value of the other object; the remainder has the same
            sign (positive or negative) as this object's value.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used both in the division portion and in the remainder
            portion of the remainder calculation. If <c>HasFlags</c> of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            additional rounding (other than the rounding from integer division)
            is needed.</param><returns>The remainder of the two numbers. Signals FlagInvalid and
            returns not-a-number (NaN) if the divisor is 0, or if the result
            doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal)">
            <summary>Calculates the remainder of a number by the formula
            <c>"this" - (("this" / "divisor") * "divisor")</c></summary><param name="divisor">The number to divide by.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the return value to
            have a higher precision than given in this context. Flags will be
            set on the given context only if the context's <c>HasFlags</c> is
            true and the integer part of the division result doesn't fit the
            precision and exponent range without rounding. Can be null, in
            which the precision is unlimited and no additional rounding, other
            than the rounding down to an integer after division, is
            needed.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RemainderNear(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value
            by another object's value.
            <list type="">
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor' s absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which the precision is
            unlimited.</param><returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest value
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary, using the
            HalfEven rounding mode.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><returns>A decimal number rounded to the closest value
            representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary, using the given
            rounding mode.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="rounding">Desired mode for rounding this number's
            value.</param><returns>A decimal number rounded to the closest value
            representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary, using the
            HalfEven rounding mode.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><returns>A decimal number rounded to the closest value
            representable for the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest value
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to a new exponent if necessary.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="rounding">The desired mode to use to round the given
            number to the given exponent.</param><returns>A decimal number rounded to the given negative number of
            decimal places.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to the given exponent, and signals an inexact
            flag if the result would be inexact.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.ERounding)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="rounding">Desired mode for rounding this object's
            value.</param><returns>A decimal number rounded to the closest value
            representable using the given exponent.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegerExact(PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>A decimal number rounded to the closest integer
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to 0
            when rounding, and 0 is outside of the valid range of the
            arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegralExact(PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A decimal number rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a decimal number with the same value as this
            object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>A decimal number rounded to the closest integer
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to 0
            when rounding, and 0 is outside of the valid range of the
            arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.RoundToPrecision(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision,
            using the given rounding mode and range of exponent.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name="ctx" /> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="places">The power of 10 to scale by.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="places">The power of 10 to scale by.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="bigPlaces">The power of 10 to scale by.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with its scale
            adjusted.</summary><param name="bigPlaces">The power of 10 to scale by.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Sqrt(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's
            value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Decimal Arithmetic Specification, any rounding mode is
            allowed.).</param><returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.SquareRoot(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's
            value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Decimal Arithmetic Specification, any rounding mode is
            allowed.).</param><returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal)">
            <summary>Subtracts an arbitrary-precision decimal number from this
            instance and returns the result.</summary><param name="otherValue">The number to subtract from this
            instance's value.</param><returns>The difference of the two objects.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Subtracts an arbitrary-precision decimal number from this
            instance.</summary><param name="otherValue">The number to subtract from this
            instance's value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToDouble">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            an arbitrary-precision integer.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the fractional part of the value would be
            lost.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the fractional part of the value would be
            lost.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEngineeringString">
            <summary>Same as ToString(), except that when an exponent is used
            it will be a multiple of 3.</summary><returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToExtendedFloat">
            <summary>Creates a binary floating-point number from this
            object's value. Note that if the binary floating-point number
            contains a negative exponent, the resulting value might not be
            exact, in which case the resulting binary float will be an
            approximation of this decimal number's value.</summary><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEFloat">
            <summary>Creates a binary floating-point number from this
            object's value. Note that if the binary floating-point number
            contains a negative exponent, the resulting value might not be
            exact, in which case the resulting binary float will be an
            approximation of this decimal number's value.</summary><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToPlainString">
            <summary>Converts this value to a string, but without using
            exponential notation.</summary><returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSingle">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToString">
            <summary>Converts this value to a string. Returns a value
            compatible with this class's FromString method.</summary><returns>A string representation of this object. The text string
            will be in exponential notation if the exponent is greater than 0
            or if the number's first nonzero digit is more than five digits
            after the decimal point.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.Ulp">
            <summary>Returns the unit in the last place. The mantissa
            (significand) will be 1 and the exponent will be this number's
            exponent. Returns 1 with an exponent of 0 if this number is
            infinity or not-a-number (NaN).</summary><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToEFloat(PeterO.Numbers.EContext)">
            <summary>Creates a binary floating-point number from this
            object's value. Note that if the binary floating-point number
            contains a negative exponent, the resulting value might not be
            exact, in which case the resulting binary float will be an
            approximation of this decimal number's value.</summary><param name="ec">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).</param><returns>an arbitrary-precision float floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetRadix">
            <summary>This is an internal method.</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetSign(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision decimal number.</param><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetMantissa(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision decimal number.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetExponent(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision decimal number.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)">
            <summary>This is an internal method.</summary><param name="bigint">An arbitrary-precision integer.</param><returns>An IShiftAccumulator object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetFlags(PeterO.Numbers.EDecimal)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision decimal number.</param><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">
            <summary>This is an internal method.</summary><param name="mantissa">The parameter <paramref name="mantissa" /> is an internal parameter.</param><param name="exponent">The parameter <paramref name="exponent" /> is an internal parameter.</param><param name="flags">The parameter <paramref name="flags" /> is an internal parameter.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetArithmeticSupport">
            <summary>This is an internal method.</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.DecimalMathHelper.ValueOf(System.Int32)">
            <summary>This is an internal method.</summary><param name="val">The parameter <paramref name="val" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><returns>This number's value, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a byte (from 0 to 255).</summary><returns>This number, converted to a byte (from 0 to 255).  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</summary><returns>This number's value as a byte (from 0 to 255).</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit signed integer.</summary><returns>This number, converted to a 16-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit signed integer.</summary><returns>This number, converted to a 64-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToDecimal">
            <summary>Converts this value to a <c>decimal</c> under the Common Language Infrastructure (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary><returns>A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromDecimal(System.Decimal)">
            <summary>Converts a <c>decimal</c> under the Common Language Infrastructure (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ) to
            an arbitrary-precision decimal.</summary><param name="dec">A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</param><returns>an arbitrary-precision decimal floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Decimal)~PeterO.Numbers.EDecimal">
            <summary>Converts an arbitrary-precision decimal number to a <c>decimal</c> under the Common Language Infrastructure (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary><param name="dec">The number to convert as an arbitrary-precision decimal floating-point number.</param><returns>A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Decimal">
            <summary>Converts an arbitrary-precision decimal's value to a <c>decimal</c> under the Common Language Infrastructure (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ),
            using the half-even rounding mode.</summary><param name="bigValue">The parameter <paramref name="bigValue" /> is an arbitrary-precision decimal floating-point number.</param><returns>A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EDecimal">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision decimal.</summary><param name="eint">An arbitrary-precision integer.</param><returns>An arbitrary-precision decimal number with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Addition(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Adds two arbitrary-precision decimal floating-point numbers and returns
            the result.</summary><param name="bthis">The first arbitrary-precision decimal floating-point number.</param><param name="otherValue">The second decimal binary floating-point number.</param><returns>The sum of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="bthis" /> or <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Subtraction(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Subtracts one arbitrary-precision decimal number from another and returns the result.</summary><param name="bthis">The first operand.</param><param name="subtrahend">The second operand.</param><returns>The difference of the two decimal numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="bthis" /> or <paramref name="subtrahend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Multiplies two decimal numbers. The resulting exponent
            will be the sum of the exponents of the two decimal
            numbers.</summary><param name="operand1">The first operand.</param><param name="operand2">The second operand.</param><returns>The product of the two decimal numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="operand1" /> or <paramref name="operand2" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Division(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Divides this object by another decimal number and returns
            the result. When possible, the result will be exact.</summary><param name="dividend">The number that will be divided by the divisor.</param><param name="divisor">The number to divide by.</param><returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating
            decimal expansion.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Modulus(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>Finds the remainder when dividing one arbitrary-precision decimal number by another.</summary><param name="dividend">The number that will be divided by the
            divisor.</param><param name="divisor">The number to divide by.</param><returns>The result of the operation.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_UnaryNegation(PeterO.Numbers.EDecimal)">
            <summary>Gets an arbitrary-precision decimal number with the same value as the given one, but with
            the sign reversed.</summary><param name="bigValue">An arbitrary-precision decimal number to negate.</param><returns>An arbitrary-precision decimal number. If this value is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision decimal floating-point number to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            an arbitrary-precision integer.</summary><param name="bigValue">The number to convert as an arbitrary-precision decimal.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Double">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><param name="bigValue">The value to convert to a 64-bit
            floating-point number.</param><returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Single">
            <summary>Converts this value to its closest equivalent as a 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><param name="bigValue">The number to convert as an arbitrary-precision decimal number.</param><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Byte">
            <summary>Converts an arbitrary-precision decimal number to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Byte)~PeterO.Numbers.EDecimal">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>The value of <paramref name="inputByte" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as an 8-bit signed integer.</summary><returns>This number, converted to an 8-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as an 8-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.SByte">
            <summary>Converts an arbitrary-precision decimal number to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.SByte)~PeterO.Numbers.EDecimal">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>The value of <paramref name="inputSByte" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int16">
            <summary>Converts an arbitrary-precision decimal number to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int16)~PeterO.Numbers.EDecimal">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>The value of <paramref name="inputInt16" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit unsigned integer.</summary><returns>This number, converted to a 16-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal number.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt16">
            <summary>Converts an arbitrary-precision decimal number to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt16)~PeterO.Numbers.EDecimal">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal number.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt16" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int32">
            <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int32)~PeterO.Numbers.EDecimal">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputInt32" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt32">
            <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt32)~PeterO.Numbers.EDecimal">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputUInt32" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int64">
            <summary>Converts an arbitrary-precision decimal number to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.Int64)~PeterO.Numbers.EDecimal">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision decimal number.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>The value of <paramref name="inputInt64" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit unsigned integer.</summary><returns>This number, converted to a 64-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal number.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt64">
            <summary>Converts an arbitrary-precision decimal number to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision decimal number.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt64)~PeterO.Numbers.EDecimal">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal number.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt64" /> as an arbitrary-precision decimal number.</returns>
        </member>
        <member name="T:PeterO.Numbers.EFloat">
            <summary>Represents an arbitrary-precision binary floating-point
            number. (The "E" stands for "extended", meaning that instances of
            this class can be values other than numbers proper, such as
            infinity and not-a-number.) Each number consists of an integer
            mantissa (significand) and an integer exponent, both
            arbitrary-precision. The value of the number equals mantissa
            (significand) * 2^exponent. This class also supports values for
            negative zero, not-a-number (NaN) values, and infinity.
            <para>Passing a signaling NaN to any arithmetic operation shown
            here will signal the flag FlagInvalid and return a quiet NaN, even
            if another operand to that operation is a quiet NaN, unless noted
            otherwise.</para>
            <para>Passing a quiet NaN to any arithmetic operation shown here
            will return a quiet NaN, unless noted otherwise.</para>
            <para>Unless noted otherwise,passing a null arbitrary-precision
            binary float argument to any method here will throw an
            exception.</para>
            <para>When an arithmetic operation signals the flag FlagInvalid,
            FlagOverflow, or FlagDivideByZero, it will not throw an exception
            too, unless the operation's trap is enabled in the precision
            context (see EContext's Traps property).</para>
            <para>An arbitrary-precision binary float value can be serialized
            in one of the following ways:</para>
            <list>
            <item>By calling the toString() method. However, not all strings
            can be converted back to an arbitrary-precision binary float
            without loss, especially if the string has a fractional
            part.</item>
            <item>By calling the UnsignedMantissa, Exponent, and IsNegative
            properties, and calling the IsInfinity, IsQuietNaN, and
            IsSignalingNaN methods. The return values combined will uniquely
            identify a particular arbitrary-precision binary float
            value.</item></list>
            <para>If an operation requires creating an intermediate value that
            might be too big to fit in memory (or might require more than 2
            gigabytes of memory to store -- due to the current use of a 32-bit
            integer internally as a length), the operation may signal an
            invalid-operation flag and return not-a-number (NaN). In certain
            rare cases, the CompareTo method may throw OutOfMemoryException
            (called OutOfMemoryError in Java) in the same circumstances.</para>
            <para><b>Thread safety</b></para>
            <para>Instances of this class are immutable, so they are inherently
            safe for use by multiple threads. Multiple instances of this object
            with the same properties are interchangeable, so they should not be
            compared using the "==" operator (which might only check if each
            side of the operator is the same instance).</para>
            <para><b>Comparison considerations</b></para>
            <para>This class's natural ordering (under the CompareTo method) is
            not consistent with the Equals method. This means that two values
            that compare as equal under the CompareTo method might not be equal
            under the Equals method. The CompareTo method compares the
            mathematical values of the two instances passed to it (and
            considers two different NaN values as equal), while two instances
            with the same mathematical value, but different exponents, will be
            considered unequal under the Equals method.</para></summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.NegativeZero">
            <summary>Represents the number negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.One">
            <summary>Represents the number 1.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.SignalingNaN">
            <summary>A not-a-number value that signals an invalid operation
            flag when it's passed as an argument to any arithmetic
            operation in arbitrary-precision binary float.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.Ten">
            <summary>Represents the number 10.</summary>
        </member>
        <member name="F:PeterO.Numbers.EFloat.Zero">
            <summary>Represents the number 0.</summary>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Exponent">
            <summary>Gets this object's exponent. This object's value
            will be an integer if the exponent is positive or zero.</summary><value>This object's exponent. This object's value will
            be an integer if the exponent is positive or zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary><value><c>true</c> if this object is finite (not infinity or
            not-a-number (NaN)); otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsNegative">
            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary><value><c>true</c> if this object is negative, including negative
            zero; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.IsZero">
            <summary>Gets a value indicating whether this object's value
            equals 0.</summary><value><c>true</c> if this object's value equals 0; otherwise,
            . <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Mantissa">
            <summary>Gets this object's unscaled value.</summary><value>This object's unscaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.Sign">
            <summary>Gets this value's sign: -1 if negative; 1 if
            positive; 0 if zero.</summary><value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
        </member>
        <member name="P:PeterO.Numbers.EFloat.UnsignedMantissa">
            <summary>Gets the absolute value of this object's unscaled
            value.</summary><value>The absolute value of this object's unscaled
            value.</value>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(System.Int32,System.Int32)">
            <summary>Creates a number with the value exponent*2^mantissa
            (significand).</summary><param name="mantissaSmall">Desired value for the mantissa.</param><param name="exponentSmall">Desired value for the exponent.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates a number with the value exponent*2^mantissa
            (significand).</summary><param name="mantissa">Desired value for the mantissa.</param><param name="exponent">Desired value for the exponent.</param><returns>An arbitrary-precision binary float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "mantissa (significand)" or <paramref name="exponent" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision binary
            float.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><returns>A quiet not-a-number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="diag" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)">
            <summary>Creates a not-a-number arbitrary-precision binary
            float.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><param name="signaling">Whether the return value will be signaling
            (true) or quiet (false).</param><param name="negative">Whether the return value is
            negative.</param><param name="ctx">An arithmetic context to control the precision
            (in bits) of the diagnostic information. The rounding and exponent
            range of this context will be ignored. Can be null. The only flag
            that can be signaled in this context is FlagInvalid, which happens
            if diagnostic information needs to be truncated and too much memory
            is required to do so.</param><returns>An arbitrary-precision binary float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="diag" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromDouble(System.Double)">
            <summary>Creates a binary float from a 64-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary><param name="dbl">The parameter <paramref name="dbl" /> is a 64-bit floating-point number.</param><returns>A binary float with the same value as <paramref name="dbl" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to the same value
            as a binary float.</summary><param name="bigint">An arbitrary-precision integer.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromSingle(System.Single)">
            <summary>Creates a binary float from a 32-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary><param name="flt">The parameter <paramref name="flt" /> is a 32-bit binary floating-point number.</param><returns>A binary float with the same value as <paramref name="flt" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)">
            <summary>Creates a binary float from a text string that represents
            a number. Note that if the string contains a negative exponent, the
            resulting value might not be exact, in which case the resulting
            binary float will be an approximation of this decimal number's
            value.
            <para>The format of the string generally consists of:</para>
            <list type="">
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            after the first digit and before the last digit.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the
            exponent.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits, or
            signaling NaN ("sNaN") followed by any number of digits, all in any
            combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is
            not allowed to contain white space characters, including
            spaces.</para></summary><param name="str">The parameter <paramref name="str" /> is a text string.</param><param name="offset">A zero-based index showing where the desired
            portion of <paramref name="str" /> begins.</param><param name="length">The length, in code units, of the desired
            portion of <paramref name="str" /> (but not more than <paramref name="str" /> 's length).</param><param name="ctx">A precision context specifying the precision,
            rounding, and exponent range (in bits) to apply to the parsed
            number. Can be null.</param><returns>The parsed number, converted to arbitrary-precision binary
            float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.ArgumentException">Either <paramref name="offset" /> or <paramref name="length" /> is less than 0 or
            greater than <paramref name="str" /> 's length, or <paramref name="str" /> ' s length minus <paramref name="offset" /> is less
            than <paramref name="length" />.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String)">
            <summary>Creates a binary float from a text string that represents
            a number, using an unlimited precision context.
      For more information, see the <c>FromString(String, int,
            int, EContext)</c> method.</summary><param name="str">A text string to convert to a binary float.</param><returns>The parsed number, converted to arbitrary-precision binary
            float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,PeterO.Numbers.EContext)">
            <summary>Creates a binary float from a text string that represents
            a number. For more information, see the <c>FromString(String, int,
            int, EContext)</c> method.</summary><param name="str">A text string to convert to a binary float.</param><param name="ctx">A precision context specifying the precision,
            rounding, and exponent range to apply to the parsed number. Can be
            null.</param><returns>The parsed number, converted to arbitrary-precision binary
            float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32)">
            <summary>Creates a binary float from a text string that represents
            a number. For more information, see the <c>FromString(String, int,
            int, EContext)</c> method.</summary><param name="str">The parameter <paramref name="str" /> is a text string.</param><param name="offset">A zero-based index showing where the desired
            portion of <paramref name="str" /> begins.</param><param name="length">The length, in code units, of the desired
            portion of <paramref name="str" /> (but not more than <paramref name="str" /> 's length).</param><returns>An arbitrary-precision binary float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.ArgumentException">Either <paramref name="offset" /> or <paramref name="length" /> is less than 0 or
            greater than <paramref name="str" /> 's length, or <paramref name="str" /> ' s length minus <paramref name="offset" /> is less
            than <paramref name="length" />.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two binary floats.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The larger value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the greater value between two binary floats.</summary><param name="first">An arbitrary-precision binary float.</param><param name="second">Another arbitrary-precision binary float.</param><returns>The larger value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the greater value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Max.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two binary floats.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The smaller value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the lesser value between two binary floats.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>The smaller value of the two numbers.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Gets the lesser value between two values, ignoring their
            signs. If the absolute values are equal, has the same effect as
            Min.</summary><param name="first">The first value to compare.</param><param name="second">The second value to compare.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.PI(PeterO.Numbers.EContext)">
            <summary>Finds the constant π, the circumference of a circle
            divided by its diameter.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as π can never be
            represented exactly.</i>.</param><returns>The constant π rounded to the given precision. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Abs">
            <summary>Finds the absolute value of this object (if it's
            negative, it becomes positive).</summary><returns>An arbitrary-precision binary float. Returns signaling
            NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Abs(PeterO.Numbers.EContext)">
            <summary>Finds the absolute value of this object (if it's
            negative, it becomes positive).</summary><param name="context">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The absolute value of this object. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat)">
            <summary>Adds this object and another binary float and returns
            the result.</summary><param name="otherValue">An arbitrary-precision binary float.</param><returns>The sum of the two objects.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the sum of this object and another object. The
            result's exponent is set to the lower of the exponents of the
            two operands.</summary><param name="otherValue">The number to add to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The sum of thisValue and the other object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareTo(PeterO.Numbers.EFloat)">
            <summary>Compares the mathematical values of this object and
            another object, accepting NaN values.
            <para>This method is not consistent with the Equals method because
            two different numbers with the same mathematical value, but
            different exponents, will compare as equal.</para>
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will not trigger an error. Instead, NaN
            will compare greater than any other number, including infinity. Two
            different NaN values will be considered equal.</para></summary><param name="other">An arbitrary-precision binary float.</param><returns>Less than 0 if this object's value is less than the other
            value, or greater than 0 if this object's value is greater than the
            other value or if <paramref name="other" /> is null, or 0 if both
            values are equal.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToSignal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object, treating quiet NaN as signaling.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method will return a quiet NaN and will signal
            a FlagInvalid flag.</para></summary><param name="other">An arbitrary-precision binary float.</param><param name="ctx">An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param><returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary><param name="other">An arbitrary-precision binary float to
            compare with this one.</param><param name="ctx">An arithmetic context. Flags will be set in this
            context only if <c>HasFlags</c> and <c>IsSimplified</c> of the
            context are true and only if an operand needed to be rounded before
            carrying out the operation. Can be null.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater. Does not signal flags if either value is signaling
            NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary><param name="other">An arbitrary-precision binary float to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            exponent has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary><param name="other">An arbitrary-precision binary float to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CompareToWithContext(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Compares the mathematical values of this object and
            another object.
            <para>In this method, negative zero and positive zero are
            considered equal.</para>
            <para>If this object or the other object is a quiet NaN or
            signaling NaN, this method returns a quiet NaN, and will signal a
            FlagInvalid flag if either is a signaling NaN.</para></summary><param name="other">An arbitrary-precision binary float.</param><param name="ctx">An arithmetic context. The precision, rounding,
            and exponent range are ignored. If <c>HasFlags</c> of the context
            is true, will store the flags resulting from the operation (the
            flags are in addition to the pre-existing flags). Can be
            null.</param><returns>Quiet NaN if this object or the other object is NaN, or 0
            if both objects have the same value, or -1 if this object is less
            than the other value, or 1 if this object is greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.CopySign(PeterO.Numbers.EFloat)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another
            number.</summary><param name="other">A number whose sign will be copied.</param><returns>An arbitrary-precision binary float.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="other" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat)">
            <summary>Divides this object by another binary float and returns
            the result. When possible, the result will be exact.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating
            binary expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this arbitrary-precision binary float by another
            arbitrary-precision binary float. The preferred exponent for the
            result is this object's exponent minus the divisor's
            exponent.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0; or, either <paramref name="ctx" />
            is null or <paramref name="ctx" /> 's precision is 0, and the result
            would have a nonterminating binary expansion; or, the rounding
            mode is ERounding.None and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision binary floats, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="desiredExponentSmall">The desired exponent. A negative
            number places the cutoff point to the right of the usual radix point (so a negative number means the number of binary digit places to
            round to). A positive number places the cutoff point to the left of
            the usual radix point.</param><param name="ctx">An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision binary floats, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="desiredExponentSmall">The desired exponent. A negative
            number places the cutoff point to the right of the usual radix point (so a negative number means the number of binary digit places to
            round to). A positive number places the cutoff point to the left of
            the usual radix point.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Divides two arbitrary-precision binary floats, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="exponent">The desired exponent. A negative number
            places the cutoff point to the right of the usual radix point (so
            a negative number means the number of binary digit places to round to).
            A positive number places the cutoff point to the left of the usual
            radix point.</param><param name="ctx">An arithmetic context object to control the
            rounding mode to use if the result must be scaled down to have the
            same exponent as this value. If the precision given in the context
            is other than 0, calls the Quantize method with both arguments
            equal to the result of the operation (and can signal FlagInvalid
            and return NaN if the result doesn't fit the given precision). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the context defines an exponent range and the
            desired exponent is outside that range. Signals FlagInvalid and
            returns not-a-number (NaN) if the rounding mode is ERounding.None
            and the result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Divides two arbitrary-precision binary floats, and gives
            a particular exponent to the result.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="desiredExponent">The desired exponent. A negative
            number places the cutoff point to the right of the usual radix point (so a negative number means the number of binary digit places to
            round to). A positive number places the cutoff point to the left of
            the usual radix point.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two objects. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Returns not-a-number (NaN) if the divisor and the dividend
            are 0. Returns NaN if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Divides two arbitrary-precision binary floats, and
            returns the integer part of the result, rounded down, with the
            preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><returns>The integer part of the quotient of the two objects.
            Signals FlagDivideByZero and returns infinity if the divisor is 0
            and the dividend is nonzero. Signals FlagInvalid and returns
            not-a-number (NaN) if the divisor and the dividend are 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result (which is initially rounded down), with
            the preferred exponent set to this value's exponent minus the
            divisor's exponent.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the integer part of the
            result. Flags will be set on the given context only if the
            context's <c>HasFlags</c> is true and the integer part of the
            result doesn't fit the precision and exponent range without
            rounding. Can be null, in which the precision is unlimited and no
            additional rounding, other than the rounding down to an integer
            after division, is needed.</param><returns>The integer part of the quotient of the two objects.
            Signals FlagInvalid and returns not-a-number (NaN) if the return
            value would overflow the exponent range. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToIntegerZeroScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Divides this object by another object, and returns the
            integer part of the result, with the exponent set to 0.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored. If <c>HasFlags</c> of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited.</param><returns>The integer part of the quotient of the two objects. The
            exponent will be set to 0. Signals FlagDivideByZero and returns
            infinity if the divisor is 0 and the dividend is nonzero. Signals
            FlagInvalid and returns not-a-number (NaN) if the divisor and the
            dividend are 0, or if the result doesn't fit the given
            precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivideToSameExponent(PeterO.Numbers.EFloat,PeterO.Numbers.ERounding)">
            <summary>Divides this object by another binary float and returns
            a result with the same exponent as this object (the
            dividend).</summary><param name="divisor">The number to divide by.</param><param name="rounding">The rounding mode to use if the result must
            be scaled down to have the same exponent as this value.</param><returns>The quotient of the two numbers. Signals FlagDivideByZero
            and returns infinity if the divisor is 0 and the dividend is
            nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
            divisor and the dividend are 0. Signals FlagInvalid and returns
            not-a-number (NaN) if the rounding mode is ERounding.None and the
            result is not exact.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Calculates the quotient and remainder using the
            DivideToIntegerNaturalScale and the formula in
            RemainderNaturalScale.</summary><param name="divisor">An arbitrary-precision binary float to
            divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the remainder to have a
            higher precision than given in this context. Flags will be set on
            the given context only if the context's <c>HasFlags</c> is true and
            the integer part of the division result doesn't fit the precision
            and exponent range without rounding. Can be null, in which the
            precision is unlimited and no additional rounding, other than the
            rounding down to an integer after division, is needed.</param><returns>A 2 element array consisting of the quotient and remainder
            in that order.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Equals(PeterO.Numbers.EFloat)">
            <summary>Determines whether this object's mantissa
            (significand), exponent, and properties are equal to those of another
            object. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="other">An arbitrary-precision binary float.</param><returns><c>true</c> if this object's mantissa (significand) and
            exponent are equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Equals(System.Object)">
            <summary>Determines whether this object's mantissa
            (significand), exponent, and properties are equal to those of another
            object and that other object is an arbitrary-precision binary float. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="obj">The parameter <paramref name="obj" /> is an arbitrary object.</param><returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.EqualsInternal(PeterO.Numbers.EFloat)">
            <summary>Determines whether this object's mantissa
            (significand) and exponent are equal to those of another
            object.</summary><param name="otherValue">An arbitrary-precision binary
            float.</param><returns><c>true</c> if this object's mantissa (significand) and
            exponent are equal to those of another object; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Exp(PeterO.Numbers.EContext)">
            <summary>Finds e (the base of natural logarithms) raised to the
            power of this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the exponential function's
            results are generally not exact.</i> (Unlike in the General Binary
            Arithmetic Specification, any rounding mode is allowed.).</param><returns>Exponential of this object. If this object's value is 1,
            returns an approximation to " e" within the given precision.
            Signals FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.GetHashCode">
            <summary>Calculates this object's hash code.  No application or process IDs are used in the hash code calculation.</summary><returns>This object's hash code.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsInfinity">
            <summary>Gets a value indicating whether this object is positive or
            negative infinity.</summary><returns><c>true</c> if this object is positive or negative
            infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsNaN">
            <summary>Gets a value indicating whether this object is not a
            number (NaN).</summary><returns><c>true</c> if this object is not a number (NaN); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary><returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary><returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsQuietNaN">
            <summary>Gets a value indicating whether this object is a quiet
            not-a-number value.</summary><returns><c>true</c> if this object is a quiet not-a-number value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.IsSignalingNaN">
            <summary>Gets a value indicating whether this object is a signaling
            not-a-number value.</summary><returns><c>true</c> if this object is a signaling not-a-number
            value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Log(PeterO.Numbers.EContext)">
            <summary>Finds the natural logarithm of this object, that is, the
            power (exponent) that e (the base of natural logarithms) must be
            raised to in order to equal this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param><returns>Ln(this object). Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the result would be a complex
            number with a real part equal to Ln of this object's absolute value
            and an imaginary part equal to pi, but the return value is still
            NaN.). Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null or the precision is
            unlimited (the context's Precision property is 0). Signals no flags
            and returns negative infinity if this object's value is
            0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Log10(PeterO.Numbers.EContext)">
            <summary>Finds the base-10 logarithm of this object, that is, the
            power (exponent) that the number 10 must be raised to in order to
            equal this object's value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the ln function's results are
            generally not exact.</i> (Unlike in the General Binary Arithmetic
            Specification, any rounding mode is allowed.).</param><returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and
            returns not-a-number (NaN) if this object is less than 0. Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the left.</summary><param name="places">The number of binary digit places to move the
            radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param><returns>A number whose exponent is decreased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the left.</summary><param name="places">The number of binary digit places to move the
            radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is decreased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the left.</summary><param name="bigPlaces">The number of binary digit places to move the
            radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param><returns>A number whose exponent is decreased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the left.</summary><param name="bigPlaces">The number of binary digit places to move the
            radix point to the left. If this number is negative, instead
            moves the radix point to the right by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is decreased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the right.</summary><param name="places">The number of binary digit places to move the
            radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param><returns>A number whose exponent is increased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the right.</summary><param name="places">The number of binary digit places to move the
            radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is increased by <paramref name="places" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the right.</summary><param name="bigPlaces">The number of binary digit places to move the
            radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the
            radix point moved to the right.</summary><param name="bigPlaces">The number of binary digit places to move the
            radix point to the right. If this number is negative, instead
            moves the radix point to the left by this number's absolute
            value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />, but not to more than 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat)">
            <summary>Multiplies two binary floats. The resulting exponent
            will be the sum of the exponents of the two binary floats.</summary><param name="otherValue">Another binary float.</param><returns>The product of the two binary floats.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies two binary floats. The resulting scale will
            be the sum of the scales of the two binary floats. The
            result's sign is positive if both operands have the same sign,
            and negative if they have different signs.</summary><param name="op">Another binary float.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>The product of the two binary floats.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Multiplies by one binary float, and then adds another
            binary float.</summary><param name="multiplicand">The value to multiply.</param><param name="augend">The value to add.</param><returns>The result this * <paramref name="multiplicand" /> +
            <paramref name="augend" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then adds another
            value.</summary><param name="op">The value to multiply.</param><param name="augend">The value to add.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and adding.</param><returns>The result thisValue * multiplicand + augend.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.MultiplyAndSubtract(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Multiplies by one value, and then subtracts another
            value.</summary><param name="op">The value to multiply.</param><param name="subtrahend">The value to subtract.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed. If the precision doesn't indicate a simplified
            arithmetic, rounding and precision/exponent adjustment is done only
            once, namely, after multiplying and subtracting.</param><returns>The result thisValue * multiplicand -
            subtrahend.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="op" /> or <paramref name="subtrahend" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Negate">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary><returns>An arbitrary-precision binary float. If this value is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Negate(PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but with the sign reversed.</summary><param name="context">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>An arbitrary-precision binary float. If this value is
            positive zero, returns positive zero. Signals FlagInvalid and
            returns quiet NaN if this value is signaling NaN.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextMinus(PeterO.Numbers.EContext)">
            <summary>Finds the largest value that's smaller than the given
            value.</summary><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the largest value that's less than the given
            value. Returns negative infinity if the result is negative
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null, the precision is 0, or
            <paramref name="ctx" /> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextPlus(PeterO.Numbers.EContext)">
            <summary>Finds the smallest value that's greater than the
            given value.</summary><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the smallest value that's greater than the given
            value.Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null, the precision is 0, or
            <paramref name="ctx" /> has an unlimited exponent range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.NextToward(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the next value that is closer to the other
            object's value than this object's value. Returns a copy
            of this value with the same sign as the other value if both values
            are equal.</summary><param name="otherValue">An arbitrary-precision binary float that
            the return value will approach.</param><param name="ctx">An arithmetic context object to control the
            precision and exponent range of the result. The rounding mode from
            this context is ignored. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags).</param><returns>Returns the next value that is closer to the other object'
            s value than this object's value. Signals FlagInvalid and returns
            NaN if the parameter <paramref name="ctx" /> is null, the precision
            is 0, or <paramref name="ctx" /> has an unlimited exponent
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Plus(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision,
            using the given rounding mode and range of exponent, and also
            converts negative zero to positive zero.</summary><param name="ctx">A context for controlling the precision, rounding
            mode, and exponent range. Can be null, in which case the precision
            is unlimited and rounding isn't needed.</param><returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name="ctx" /> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponent">An arbitrary-precision binary float
            expressing the exponent to raise this object's value to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0; or if this value is
            less than 0 and the exponent either has a fractional part or is
            infinity. Signals FlagInvalid and returns not-a-number (NaN) if the
            parameter <paramref name="ctx" /> is null or the precision is
            unlimited (the context's Precision property is 0), and the exponent
            has a fractional part.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(System.Int32,PeterO.Numbers.EContext)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponentSmall">The exponent to raise this object's
            value to.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This^exponent. Signals the flag FlagInvalid and returns
            NaN if this object and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Pow(System.Int32)">
            <summary>Raises this object's value to the given
            exponent.</summary><param name="exponentSmall">The exponent to raise this object's
            value to.</param><returns>This^exponent. Returns not-a-number (NaN) if this object
            and exponent are both 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Precision">
            <summary>Finds the number of digits in this number's mantissa
            (significand). Returns 1 if this value is 0, and 0 if this value is
            infinity or not-a-number (NaN).</summary><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>
            Returns a binary float with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point binary arithmetic, in which each binary float has a
            fixed number of digits after the radix point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the radix point:</para>
            <code>
            // After performing arithmetic operations, adjust
            // the number to 5
            // digits after the radix point
            number = number.Quantize(
            EInteger.FromInt32(-5),  // five digits after the radix point
            EContext.ForPrecision(25)  // 25-digit precision);
            </code>
            <para>A fixed-point binary arithmetic in which no digits come
            after the radix point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary><param name="desiredExponent">The desired exponent for the result.
            The exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A binary float with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if this object is infinity, if the rounded
            result can't fit the given precision, or if the context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(System.Int32,PeterO.Numbers.EContext)">
            <summary>
            Returns a binary float with the same value but a new
            exponent.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b>
             This method can be used to implement
            fixed-point binary arithmetic, in which each binary float has a
            fixed number of digits after the radix point. The following code
            example returns a fixed-point number with up to 20 digits before
            and exactly 5 digits after the radix point:</para>
            <code>
            // After performing arithmetic operations, adjust  // the number to 5
            digits after the radix point number = number.Quantize(-5,  // five
            digits after the radix point EContext.ForPrecision(25)  // 25-digit
            precision);
            </code>
            <para>A fixed-point binary arithmetic in which no digits come
            after the radix point (a desired exponent of 0) is considered an
            "integer arithmetic".</para>
            </summary><param name="desiredExponentInt">The desired exponent for the
            result. The exponent is the number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c>
             of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A binary float with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if this object is infinity, if the rounded
            result can't fit the given precision, or if the context defines an
            exponent range and the given exponent is outside that
            range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but with the same exponent as another binary float.
            <para>Note that this is not always the same as rounding to a given
            number of binary digit places, since it can fail if the difference
            between this value's exponent and the desired exponent is too big,
            depending on the maximum precision. If rounding to a number of
            binary digit places is desired, it's better to use the RoundToExponent
            and RoundToIntegral methods instead.</para>
            <para><b>Remark:</b> This method can be used to implement
            fixed-point binary arithmetic, in which a fixed number of digits
            come after the radix point. A fixed-point binary arithmetic in
            which no digits come after the radix point (a desired exponent of
            0) is considered an "integer arithmetic".</para></summary><param name="otherValue">A binary float containing the desired
            exponent of the result. The mantissa (significand) is ignored. The
            exponent is the number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which eliminates lower-order places from the number. For example, -3 means round to the sixteenth (10b^-3, 0.0001b), and 3 means round to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number to an integer.</param><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags). Can be null, in which
            case the default rounding mode is HalfEven.</param><returns>A binary float with the same value as this object but
            with the exponent changed. Signals FlagInvalid and returns
            not-a-number (NaN) if the result can't fit the given precision
            without rounding, or if the arithmetic context defines an exponent
            range and the given exponent is outside that range.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Reduce(PeterO.Numbers.EContext)">
            <summary>Removes trailing zeros from this object's mantissa
            (significand). For example, 1.00 becomes 1.
            <para>If this object's value is 0, changes the exponent to
            0.</para></summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and rounding
            isn't needed.</param><returns>This value with trailing zeros removed. Note that if the
            result has a very high exponent and the context says to clamp high
            exponents, there may still be some trailing zeros in the mantissa
            (significand).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the remainder that results when dividing two
            arbitrary-precision binary floats. The remainder is the value
            that remains when the absolute value of this object is divided by
            the absolute value of the other object; the remainder has the same
            sign (positive or negative) as this object's value.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used both in the division portion and in the remainder
            portion of the remainder calculation. If <c>HasFlags</c> of the
            context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            additional rounding (other than the rounding from integer division)
            is needed.</param><returns>The remainder of the two numbers. Signals FlagInvalid and
            returns not-a-number (NaN) if the divisor is 0, or if the result
            doesn't fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat)">
            <summary>Calculates the remainder of a number by the formula
            <c>"this" - (("this" / "divisor") * "divisor")</c></summary><param name="divisor">The number to divide by.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Calculates the remainder of a number by the formula "this"
            - (("this" / "divisor") * "divisor").</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only in the division portion of the remainder
            calculation; as a result, it's possible for the return value to
            have a higher precision than given in this context. Flags will be
            set on the given context only if the context's <c>HasFlags</c> is
            true and the integer part of the division result doesn't fit the
            precision and exponent range without rounding. Can be null, in
            which the precision is unlimited and no additional rounding, other
            than the rounding down to an integer after division, is
            needed.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RemainderNear(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Finds the distance to the closest multiple of the given
            divisor, based on the result of dividing this object's value
            by another object's value.
            <list type="">
            <item>If this and the other object divide evenly, the result is
            0.</item>
            <item>If the remainder's absolute value is less than half of the
            divisor's absolute value, the result has the same sign as this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is more than half of the
            divisor' s absolute value, the result has the opposite sign of this
            object and will be the distance to the closest multiple.</item>
            <item>If the remainder's absolute value is exactly half of the
            divisor's absolute value, the result has the opposite sign of this
            object if the quotient, rounded down, is odd, and has the same sign
            as this object if the quotient, rounded down, is even, and the
            result's absolute value is half of the divisor's absolute
            value.</item></list> This function is also known as the "IEEE
            Remainder" function.</summary><param name="divisor">The number to divide by.</param><param name="ctx">An arithmetic context object to control the
            precision. The rounding and exponent range settings of this context
            are ignored (the rounding mode is always treated as HalfEven). If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null, in which the precision is
            unlimited.</param><returns>The distance of the closest multiple. Signals FlagInvalid
            and returns not-a-number (NaN) if the divisor is 0, or either the
            result of integer division (the quotient) or the remainder wouldn't
            fit the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to a new exponent if necessary.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest value
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponent(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to a new exponent if necessary.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest value
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to the
            given exponent when rounding, and the given exponent is outside of
            the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to the given exponent, and signals an inexact
            flag if the result would be inexact.</summary><param name="exponent">The minimum exponent the result can have.
            This is the maximum number of fractional digits in the result,
            expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)">
            <summary>Returns a binary number with the same value as this object
            but rounded to the given exponent.</summary><param name="exponent">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the eighth (10^-1, 1/8), and 3 means round to
            the eight (2^3, 8). A value of 0 rounds the number to an
            integer.</param><param name="rounding">Desired mode for rounding this object's
            value.</param><returns>A binary number rounded to the closest value representable
            in the given precision.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="exponentSmall">The minimum exponent the result can
            have. This is the maximum number of fractional digits in the
            result, expressed as a negative number. Can also be positive, which
            eliminates lower-order places from the number. For example, -3
            means round to the thousandth (10^-3, 0.0001), and 3 means round to
            the thousand (10^3, 1000). A value of 0 rounds the number to an
            integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest value
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to the given exponent when
            rounding, and the given exponent is outside of the valid range of
            the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegerExact(PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>A binary float rounded to the closest integer
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to 0
            when rounding, and 0 is outside of the valid range of the
            arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegralExact(PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to an integer, and signals an inexact flag if
            the result would be inexact.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the default rounding mode is
            HalfEven.</param><returns>A binary float rounded to the closest integer
            representable in the given precision. Signals FlagInvalid and
            returns not-a-number (NaN) if the result can't fit the given
            precision without rounding. Signals FlagInvalid and returns
            not-a-number (NaN) if the arithmetic context defines an exponent
            range, the new exponent must be changed to 0 when rounding, and 0
            is outside of the valid range of the arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)">
            <summary>Returns a binary float with the same value as this
            object but rounded to an integer, without adding the
            <c>FlagInexact</c> or <c>FlagRounded</c> flags.</summary><param name="ctx">An arithmetic context to control precision and
            rounding of the result. If <c>HasFlags</c> of the context is true,
            will also store the flags resulting from the operation (the flags
            are in addition to the pre-existing flags), except that this
            function will never add the <c>FlagRounded</c> and
            <c>FlagInexact</c> flags (the only difference between this and
            RoundToExponentExact). Can be null, in which case the default
            rounding mode is HalfEven.</param><returns>A binary float rounded to the closest integer
            representable in the given precision. If the result can't fit the
            precision, additional digits are discarded to make it fit. Signals
            FlagInvalid and returns not-a-number (NaN) if the precision context
            defines an exponent range, the new exponent must be changed to 0
            when rounding, and 0 is outside of the valid range of the
            arithmetic context.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.RoundToPrecision(PeterO.Numbers.EContext)">
            <summary>Rounds this object's value to a given precision,
            using the given rounding mode and range of exponent.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The closest value to this object's value, rounded to the
            specified precision. Returns the same value as this object if
            <paramref name="ctx" /> is null or the precision and exponent range
            are unlimited.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="places">The parameter <paramref name="places" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="places">The parameter <paramref name="places" /> is a 32-bit signed integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger)">
            <summary>Returns a number similar to this number but with the scale
            adjusted.</summary><param name="bigPlaces">An arbitrary-precision integer.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)">
            <summary>Returns a number similar to this number but with its scale
            adjusted.</summary><param name="bigPlaces">An arbitrary-precision integer.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null.</param><returns>A number whose exponent is increased by <paramref name="bigPlaces" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Sqrt(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's
            value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Binary Arithmetic Specification, any rounding mode is
            allowed.).</param><returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.SquareRoot(PeterO.Numbers.EContext)">
            <summary>Finds the square root of this object's
            value.</summary><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            <i>This parameter can't be null, as the square root function's
            results are generally not exact for many inputs.</i> (Unlike in the
            General Binary Arithmetic Specification, any rounding mode is
            allowed.).</param><returns>The square root. Signals the flag FlagInvalid and returns
            NaN if this object is less than 0 (the square root would be a
            complex number, but the return value is still NaN). Signals
            FlagInvalid and returns not-a-number (NaN) if the parameter
            <paramref name="ctx" /> is null or the precision is unlimited (the
            context's Precision property is 0).</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat)">
            <summary>Subtracts an arbitrary-precision binary float from this
            instance and returns the result.</summary><param name="otherValue">The number to subtract from this
            instance's value.</param><returns>The difference of the two objects.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)">
            <summary>Subtracts an arbitrary-precision binary float from this
            instance.</summary><param name="otherValue">The number to subtract from this
            instance's value.</param><param name="ctx">An arithmetic context to control precision,
            rounding, and exponent range of the result. If <c>HasFlags</c> of
            the context is true, will also store the flags resulting from the
            operation (the flags are in addition to the pre-existing flags).
            Can be null, in which case the precision is unlimited and no
            rounding is needed.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToDouble">
            <summary>Converts this value to a 64-bit floating-point number.</summary><returns>This number, converted to a 64-bit floating-point number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEDecimal">
            <summary>Converts this value to an arbitrary-precision decimal
            number.</summary><returns>This number, converted to an arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer. Any
            fractional part of this value will be discarded when converting to
            an arbitrary-precision integer.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value contains a fractional part.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value contains a fractional part.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToEngineeringString">
            <summary>Converts this value to an arbitrary-precision decimal
            number, then returns the value of that decimal's
            ToEngineeringString method.</summary><returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToExtendedDecimal">
            <summary>Converts this value to an arbitrary-precision decimal
            number.</summary><returns>An arbitrary-precision decimal number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToPlainString">
            <summary>Converts this value to a string, but without exponential
            notation.</summary><returns>A text string.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToShortestString(PeterO.Numbers.EContext)">
            <summary>Returns a string representation of this number's value
            after rounding to the given precision (using the given arithmetic
            context). If the number after rounding
            is neither infinity nor not-a-number (NaN), returns the shortest
            decimal form (in terms of nonzero decimal digits) of this number's
            value that results in the rounded number after the decimal form is
            converted to binary floating-point format (using the given arithmetic
            context).</summary><param name="ctx">An arithmetic context to control precision (in
            bits), rounding, and exponent range of the rounded number. If
            <c>HasFlags</c> of the context is true, will also store the flags
            resulting from the operation (the flags are in addition to the
            pre-existing flags). Can be null. If this parameter is null or
            defines no maximum precision, returns the same value as the
            ToString() method.</param><returns>Shortest decimal form of this number's value for the given
            arithmetic context. The text string will be in exponential notation
            if the number's first nonzero decimal digit is more than five
            digits after the decimal point, or if the number's exponent is
            greater than 0 and its value is 10, 000, 000 or greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSingle">
            <summary>Converts this value to its closest equivalent as 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToString">
            <summary>Converts this number's value to a text string.</summary><returns>A string representation of this object. The value is
            converted to decimal and the decimal form of this number's value is
            returned. The text string will be in exponential notation if the
            converted number's scale is positive or if the number's first
            nonzero decimal digit is more than five digits after the decimal
            point.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.Ulp">
            <summary>Returns the unit in the last place. The mantissa
            (significand) will be 1 and the exponent will be this number's
            exponent. Returns 1 with an exponent of 0 if this number is
            infinity or not-a-number (NaN).</summary><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetRadix">
            <summary>This is an internal method.</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetSign(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision binary float.</param><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetMantissa(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision binary float.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetExponent(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision binary float.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulatorWithDigits(PeterO.Numbers.EInteger,System.Int32,System.Int32)">
            <summary>This is an internal method.</summary><param name="bigint">An arbitrary-precision integer.</param><param name="lastDigit">The parameter <paramref name="lastDigit" /> is a 32-bit signed integer.</param><param name="olderDigits">The parameter <paramref name="olderDigits" /> is a 32-bit signed integer.</param><returns>An IShiftAccumulator object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)">
            <summary>This is an internal method.</summary><param name="bigint">An arbitrary-precision integer.</param><returns>An IShiftAccumulator object.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.DivisionShift(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>This is an internal method.</summary><param name="num">An arbitrary-precision integer.</param><param name="den">Another arbitrary-precision integer.</param><returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.MultiplyByRadixPower(PeterO.Numbers.EInteger,PeterO.Numbers.FastInteger)">
            <summary>This is an internal method.</summary><param name="bigint">Another arbitrary-precision integer.</param><param name="power">A fast integer.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetFlags(PeterO.Numbers.EFloat)">
            <summary>This is an internal method.</summary><param name="value">An arbitrary-precision binary float.</param><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)">
            <summary>This is an internal method.</summary><param name="mantissa">The parameter <paramref name="mantissa" /> is an internal parameter.</param><param name="exponent">The parameter <paramref name="exponent" /> is an internal parameter.</param><param name="flags">The parameter <paramref name="flags" /> is an internal parameter.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.GetArithmeticSupport">
            <summary>This is an internal method.</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.BinaryMathHelper.ValueOf(System.Int32)">
            <summary>This is an internal method.</summary><param name="val">The parameter <paramref name="val" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><returns>This number's value, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a byte (from 0 to 255).</summary><returns>This number, converted to a byte (from 0 to 255).  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</summary><returns>This number's value as a byte (from 0 to 255).</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit signed integer.</summary><returns>This number, converted to a 16-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit signed integer.</summary><returns>This number, converted to a 64-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Single)~PeterO.Numbers.EFloat">
            <summary>Creates a binary float from a 32-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary><param name="flt">The parameter <paramref name="flt" /> is a 32-bit binary floating-point number.</param><returns>A binary float with the same value as <paramref name="flt" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Double)~PeterO.Numbers.EFloat">
            <summary>Creates a binary float from a 64-bit floating-point
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the floating point number to a string first.</summary><param name="dbl">The parameter <paramref name="dbl" /> is a 64-bit floating-point number.</param><returns>A binary float with the same value as <paramref name="dbl" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EFloat">
            <summary>Converts an arbitrary-precision integer to an arbitrary
            precision binary.</summary><param name="eint">An arbitrary-precision integer.</param><returns>An arbitrary-precision binary float with the exponent
            set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Addition(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Adds two arbitrary-precision binary floating-point numbers and returns
            the result.</summary><param name="bthis">The first arbitrary-precision binary floating-point number.</param><param name="otherValue">The second arbitrary-precision binary floating-point number.</param><returns>The sum of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="bthis" /> or <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Subtraction(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Subtracts one arbitrary-precision binary float from another.</summary><param name="bthis">The first operand.</param><param name="subtrahend">The second operand.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="bthis" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Multiplies two binary floats. The resulting exponent
            will be the sum of the exponents of the two binary floats.</summary><param name="operand1">The first operand.</param><param name="operand2">The second operand.</param><returns>The product of the two binary floats.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="operand1" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Division(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Divides one binary float by another and returns
            the result. When possible, the result will be exact.</summary><param name="dividend">The number that will be divided by the divisor.</param><param name="divisor">The number to divide by.</param><returns>The quotient of the two numbers. Returns infinity if the
            divisor is 0 and the dividend is nonzero. Returns not-a-number
            (NaN) if the divisor and the dividend are 0. Returns NaN if the
            result can't be exact because it would have a nonterminating
            binary expansion.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Modulus(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)">
            <summary>Finds the remainder when dividing one arbitrary-precision binary float by another.</summary><param name="dividend">The number that will be divided by the
            divisor.</param><param name="divisor">The number to divide by.</param><returns>The result of the operation.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_UnaryNegation(PeterO.Numbers.EFloat)">
            <summary>Gets an object with the same value as this one, but with
            the sign reversed.</summary><param name="bigValue">An arbitrary-precision binary float.</param><returns>The negated form of the given number.  If the given number is
            positive zero, returns negative zero. Returns signaling NaN if this
            value is signaling NaN.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision binary float to a value to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            an arbitrary-precision integer.</summary><param name="bigValue">The number to convert as an arbitrary-precision binary float.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Double">
            <summary>Converts this value to its closest equivalent as a 64-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 64-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><param name="bigValue">The value to convert to a 64-bit
            floating-point number.</param><returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Single">
            <summary>Converts an arbitrary-precision binary float to its closest equivalent as a 32-bit
            floating-point number. The half-even rounding mode is used.
            <para>If this value is a NaN, sets the high bit of the 32-bit
            floating point number's significand area for a quiet NaN, and
            clears it for a signaling NaN. Then the other bits of the
            significand area are set to the lowest bits of this object's unsigned
            mantissa (significand), and the next-highest bit of the
            significand area is set if those bits are all
            zeros and this is a signaling NaN. Unfortunately, in the .NET implementation, the return value of this method may be a quiet NaN even if a signaling NaN would otherwise be generated.</para></summary><param name="bigValue">The number to convert as an arbitrary-precision binary float.</param><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Byte">
            <summary>Converts an arbitrary-precision binary float to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Byte)~PeterO.Numbers.EFloat">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>The value of <paramref name="inputByte" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as an 8-bit signed integer.</summary><returns>This number, converted to an 8-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as an 8-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.SByte">
            <summary>Converts an arbitrary-precision binary float to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.SByte)~PeterO.Numbers.EFloat">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>The value of <paramref name="inputSByte" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int16">
            <summary>Converts an arbitrary-precision binary float to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int16)~PeterO.Numbers.EFloat">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>The value of <paramref name="inputInt16" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit unsigned integer.</summary><returns>This number, converted to a 16-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary float.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt16">
            <summary>Converts an arbitrary-precision binary float to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt16)~PeterO.Numbers.EFloat">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary float.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt16" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int32">
            <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int32)~PeterO.Numbers.EFloat">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputInt32" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt32">
            <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt32)~PeterO.Numbers.EFloat">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputUInt32" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int64">
            <summary>Converts an arbitrary-precision binary float to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.Int64)~PeterO.Numbers.EFloat">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>The value of <paramref name="inputInt64" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit unsigned integer.</summary><returns>This number, converted to a 64-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary float.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision binary float.</returns>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt64">
            <summary>Converts an arbitrary-precision binary float to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision binary float.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EFloat.op_Implicit(System.UInt64)~PeterO.Numbers.EFloat">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary float.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt64" /> as an arbitrary-precision binary float.</returns>
        </member>
        <member name="T:PeterO.Numbers.EInteger">
            <summary>Represents an arbitrary-precision integer. (The "E" stands
             for "extended", and has this prefix to group it with the other
             classes common to this library, particularly EDecimal, EFloat, and
             ERational.)
             <para>Instances of this class are immutable, so they are inherently
             safe for use by multiple threads. Multiple instances of this object
             with the same value are interchangeable, but they should be
             compared using the "Equals" method rather than the "=="
             operator.</para></summary>
            <summary>Represents an arbitrary-precision integer. (The "E" stands
             for "extended", and has this prefix to group it with the other
             classes common to this library, particularly EDecimal, EFloat, and
             ERational.)
             <para>Instances of this class are immutable, so they are inherently
             safe for use by multiple threads. Multiple instances of this object
             with the same value are interchangeable, but they should be
             compared using the "Equals" method rather than the "=="
             operator.</para></summary>
        </member>
        <member name="P:PeterO.Numbers.EInteger.One">
            <summary>Gets the number 1 as an arbitrary-precision
            integer.</summary><value>The number 1 as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Ten">
            <summary>Gets the number 10 as an arbitrary-precision
            integer.</summary><value>The number 10 as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Zero">
            <summary>Gets the number zero as an arbitrary-precision integer.</summary><value>The number zero as an arbitrary-precision integer.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsEven">
            <summary>Gets a value indicating whether this value is
            even.</summary><value><c>true</c> if this value is even; otherwise, <c>false</c>
            .</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsPowerOfTwo">
            <summary>Gets a value indicating whether this object's value
            is a power of two.</summary><value><c>true</c> if this object's value is a power of two; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.IsZero">
            <summary>Gets a value indicating whether this value is 0.</summary><value><c>true</c> if this value is 0; otherwise, <c>false</c>
            .</value>
        </member>
        <member name="P:PeterO.Numbers.EInteger.Sign">
            <summary>Gets the sign of this object's value.</summary><value>0 if this value is zero; -1 if this value is negative, or 1
            if this value is positive.</value>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Boolean)">
            <summary>Initializes an arbitrary-precision integer from an array
            of bytes.</summary><param name="bytes">A byte array consisting of the two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            of the arbitrary-precision integer to create. The byte array is
            encoded using the following rules:
            <list>
            <item>Positive numbers have the first byte's highest bit cleared,
            and negative numbers have the bit set.</item>
            <item>The last byte contains the lowest 8-bits, the next-to-last
            contains the next lowest 8 bits, and so on. For example, the number
            300 can be encoded as <c>0x01, 0x2C</c> and 200 as <c>0x00,
            0xC8</c>. (Note that the second example contains a set high bit in
            <c>0xC8</c>, so an additional 0 is added at the start to ensure
            it's interpreted as positive.)</item>
            <item>To encode negative numbers, take the absolute value of the
            number, subtract by 1, encode the number into bytes, and toggle
            each bit of each byte. Any further bits that appear beyond the most
            significant bit of the number will be all ones. For example, the
            number -450 can be encoded as <c>0xfe, 0x70</c> and -52869 as
            <c>0xff, 0x31, 0x7B</c>. (Note that the second example contains a
            cleared high bit in <c>0x31, 0x7B</c>, so an additional 0xff is
            added at the start to ensure it's interpreted as
            negative.)</item></list>
            <para>For little-endian, the byte order is reversed from the byte
            order just discussed.</para>.</param><param name="littleEndian">If true, the byte order is
            little-endian, or least-significant-byte first. If false, the byte
            order is big-endian, or most-significant-byte first.</param><returns>An arbitrary-precision integer. Returns 0 if the byte
            array's length is 0.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bytes" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision
            integer.</summary><param name="intValue">The parameter <paramref name="intValue" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision integer with the same value as the
            64-bit number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision
            integer.</summary><param name="longerValue">The parameter <paramref name="longerValue" /> is a 64-bit signed integer.</param><returns>An arbitrary-precision integer with the same value as the
            64-bit number.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixString(System.String,System.Int32)">
            <summary>Converts a string to an arbitrary-precision
            integer in a given radix.</summary><param name="str">A string described by the FromRadixSubstring method.</param><param name="radix">A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039)
            and then the basic letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</param><returns>An arbitrary-precision integer with the same value as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter <paramref name="str" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Converts a portion of a string to an arbitrary-precision
            integer in a given radix.</summary><param name="str">A text string. The desired portion of the string
            must contain only characters allowed by the given radix, except
            that it may start with a minus sign ("-", U+002D) to indicate a
            negative number. The desired portion is not allowed to contain
            white space characters, including spaces.</param><param name="radix">A base from 2 to 36. Depending on the radix,
            the string can use the basic digits 0 to 9 (U+0030 to U+0039)
            and then the basic letters A to Z (U+0041 to U+005A). For
            example, 0-9 in radix 10, and 0-9, then A-F in radix 16.</param><param name="index">The index of the string that starts the string
            portion.</param><param name="endIndex">The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param><returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="index" /> is less than 0, <paramref name="endIndex" /> is less than 0, or either is greater than the
            string's length, or <paramref name="endIndex" /> is less than
            <paramref name="index" />.</exception><exception cref="T:System.FormatException">The string portion is
            empty or in an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromString(System.String)">
            <summary>Converts a string to an arbitrary-precision
            integer.</summary><param name="str">A text string. The string must contain only basic
            digits 0 to 9 (U+0030 to U+0039), except that it may start with
            a minus sign ("-", U+002D) to indicate a negative number. The
            string is not allowed to contain white space characters, including
            spaces.</param><returns>An arbitrary-precision integer with the same value as
            given in the string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is in an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSubstring(System.String,System.Int32,System.Int32)">
            <summary>Converts a portion of a string to an arbitrary-precision
            integer.</summary><param name="str">A text string. The desired portion of the string
            must contain only basic digits 0 to 9 (U+0030 to U+0039),
            except that it may start with a minus sign ("-", U+002D) to
            indicate a negative number. The desired portion is not allowed to
            contain white space characters, including spaces.</param><param name="index">The index of the string that starts the string
            portion.</param><param name="endIndex">The index of the string that ends the string
            portion. The length will be index + endIndex - 1.</param><returns>An arbitrary-precision integer with the same value as
            given in the string portion.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="index" /> is less than 0, <paramref name="endIndex" /> is less than 0, or either is greater than the
            string's length, or <paramref name="endIndex" /> is less than
            <paramref name="index" />.</exception><exception cref="T:System.FormatException">The string portion is
            empty or in an invalid format.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Abs">
            <summary>Returns the absolute value of this object's
            value.</summary><returns>This object's value with the sign removed.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Add(PeterO.Numbers.EInteger)">
            <summary>Adds this object and another object.</summary><param name="bigintAugend">Another arbitrary-precision
            integer.</param><returns>The sum of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintAugend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt32Checked">
            <summary>Converts this object's value to a 32-bit signed integer,
            throwing an exception if it can't fit.</summary><returns>A 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This object's value is
            too big to fit a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt32Unchecked">
            <summary>Converts this object's value to a 32-bit signed integer.
            If the value can't fit in a 32-bit integer, returns the lower 32
            bits of this object's two' s-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            (in which case the return value might have a different sign than
            this object's value).</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt64Checked">
            <summary>Converts this object's value to a 64-bit signed integer,
            throwing an exception if it can't fit.</summary><returns>A 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This object's value is
            too big to fit a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.AsInt64Unchecked">
            <summary>Converts this object's value to a 64-bit signed integer.
            If the value can't fit in a 64-bit integer, returns the lower 64
            bits of this object's two' s-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            (in which case the return value might have a different sign than
            this object's value).</summary><returns>A 64-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CanFitInInt32">
            <summary>Returns whether this object's value can fit in a 32-bit
            signed integer.</summary><returns><c>true</c> if this object's value is from -2147483648 through
            2147483647; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CanFitInInt64">
            <summary>Returns whether this object's value can fit in a 64-bit
            signed integer.</summary><returns><c>true</c> if this object's value is from -9223372036854775808
through 9223372036854775807; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.CompareTo(PeterO.Numbers.EInteger)">
            <summary>Compares an arbitrary-precision integer with this
            instance.</summary><param name="other">The integer to compare to this value.</param><returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Divide(PeterO.Numbers.EInteger)">
            <summary>Divides this instance by the value of an
            arbitrary-precision integer. The result is rounded down (the
            fractional part is discarded). Except if the result is 0, it will
            be negative if this object is positive and the other is negative,
            or vice versa, and will be positive if both are positive or both
            are negative.</summary><param name="bigintDivisor">Another arbitrary-precision
            integer.</param><returns>The quotient of the two objects.</returns><exception cref="T:System.DivideByZeroException">The parameter
            <paramref name="bigintDivisor" /> is zero.</exception><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintDivisor" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger)">
            <summary>Divides this object by another arbitrary-precision integer
            and returns the quotient and remainder.</summary><param name="divisor">The number to divide by.</param><returns>An array with two arbitrary-precision integers: the first
            is the quotient, and the second is the remainder.</returns><exception cref="T:System.ArgumentNullException">The parameter
            divisor is null.</exception><exception cref="T:System.DivideByZeroException">The parameter
            divisor is 0.</exception><exception cref="T:System.DivideByZeroException">Attempted to
            divide by zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Equals(System.Object)">
            <summary>Determines whether this object and another object are
            equal and have the same type.</summary><param name="obj">The parameter <paramref name="obj" /> is an arbitrary object.</param><returns><c>true</c> if this object and another object are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Gcd(PeterO.Numbers.EInteger)">
            <summary>Returns the greatest common divisor of this integer and the given integer. The
            greatest common divisor (GCD) is also known as the greatest common
            factor (GCF).</summary><param name="bigintSecond">Another arbitrary-precision
            integer.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintSecond" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetDigitCount">
            <summary>Returns the number of decimal digits used by this integer.</summary><returns>The number of digits in the decimal form of this integer.  Returns 1 if this number is 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetHashCode">
            <summary>Returns the hash code for this instance.  No application or process IDs are used in the hash code calculation.</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetLowBit">
            <summary>Gets the lowest set bit in this number's absolute value.
            (This will also be the lowest set bit in the number's
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see>
            ).).</summary><returns>The lowest bit set in the number, starting at 0. Returns
            -1 if this value is 0 or odd.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetLowBitAsEInteger">
            <summary>Gets the lowest set bit in this number's absolute value.
            (This will also be the lowest set bit in the number's
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see>
            ).).</summary><returns>The lowest bit set in the number, starting at 0. Returns
            -1 if this value is 0 or odd.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBit(System.Int32)">
            <summary>Returns whether a bit is set in the two's-complement form
            (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            of this object' s value.</summary><param name="index">Zero based index of the bit to test. 0 means
            the least significant bit.</param><returns><c>true</c> if a bit is set in the two's-complement form
            (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            of this object' s value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetSignedBitLength">
            <summary>Finds the minimum number of bits needed to represent this
            object's value, except for its sign. If the value is negative,
            finds the number of bits in the value equal to this object's
            absolute value minus 1.</summary><returns>The number of bits in this object's value. Returns 0 if
            this object's value is 0 or negative 1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBit(System.Int32)">
            <summary>Returns whether a bit is set in this number's absolute
            value.</summary><param name="index">Zero based index of the bit to test. 0 means
            the least significant bit.</param><returns><c>true</c> if a bit is set in this number's absolute
            value.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsEInteger">
            <summary>Finds the minimum number of bits needed to represent this
            number's absolute value.</summary><returns>The number of bits in this object's value. Returns 0 if
            this object's value is 0, and returns 1 if the value is negative
            1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetUnsignedBitLength">
            <summary>Finds the minimum number of bits needed to represent this
            number's absolute value.</summary><returns>The number of bits in this object's value. Returns 0 if
            this object's value is 0, and returns 1 if the value is negative
            1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Mod(PeterO.Numbers.EInteger)">
            <summary>Finds the modulus remainder that results when this
            instance is divided by the value of an arbitrary-precision integer.
            The modulus remainder is the same as the normal remainder if the
            normal remainder is positive, and equals divisor plus normal
            remainder if the normal remainder is negative.</summary><param name="divisor">A divisor greater than 0 (the
            modulus).</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArithmeticException">The parameter
            <paramref name="divisor" /> is negative.</exception><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="divisor" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Calculates the remainder when this arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary><param name="pow">The power to raise this integer by.</param><param name="mod">The integer to divide the raised number by.</param><returns>The value ( <c>this</c> ^ <paramref name="pow" /> )% <paramref name="mod" />.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="pow" /> or <paramref name="mod" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Multiply(PeterO.Numbers.EInteger)">
            <summary>Multiplies this instance by the value of an
            arbitrary-precision integer object.</summary><param name="bigintMult">Another arbitrary-precision
            integer.</param><returns>The product of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintMult" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Negate">
            <summary>Gets the value of this object with the sign
            reversed.</summary><returns>This object's value with the sign reversed.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Pow(System.Int32)">
            <summary>Raises an arbitrary-precision integer to a
            power.</summary><param name="powerSmall">The exponent to raise to.</param><returns>The result. Returns 1 if <paramref name="powerSmall" /> is
            0.</returns><exception cref="T:System.ArgumentException">The parameter
            <paramref name="powerSmall" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.PowBigIntVar(PeterO.Numbers.EInteger)">
            <summary>Raises an arbitrary-precision integer to a power, which is
            given as another arbitrary-precision integer.</summary><param name="power">The exponent to raise to.</param><returns>The result. Returns 1 if <paramref name="power" /> is
            0.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="power" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="power" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Remainder(PeterO.Numbers.EInteger)">
            <summary>Finds the remainder that results when this instance is
            divided by the value of an arbitrary-precision integer. The
            remainder is the value that remains when the absolute value of this
            object is divided by the absolute value of the other object; the
            remainder has the same sign (positive or negative) as this
            object.</summary><param name="divisor">Another arbitrary-precision integer.</param><returns>The remainder of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="divisor" /> is null.</exception><exception cref="T:System.DivideByZeroException">Attempted to
            divide by zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftLeft(System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the left by a number of bits. A value of 1 doubles this
            value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
            of 4 by 16, and so on.</summary><param name="numberBits">The number of bits to shift. Can be
            negative, in which case this is the same as shiftRight with the
            absolute value of this parameter.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ShiftRight(System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the right. For this operation, the arbitrary-precision
            integer is treated as a two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ).
            Thus, for negative values, the arbitrary-precision integer is
            sign-extended.</summary><param name="numberBits">Number of bits to shift right.</param><returns>An arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Sqrt">
            <summary>Finds the square root of this instance's value,
            rounded down.</summary><returns>The square root of this object's value. Returns 0 if this
            value is 0 or less.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.SqrtRem">
            <summary>Calculates the square root and the remainder.</summary><returns>An array of two arbitrary-precision integers: the first
            integer is the square root, and the second is the difference
            between this value and the square of the first integer. Returns two
            zeros if this value is 0 or less, or one and zero if this value
            equals 1.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Subtract(PeterO.Numbers.EInteger)">
            <summary>Subtracts an arbitrary-precision integer from this
            arbitrary-precision integer.</summary><param name="subtrahend">Another arbitrary-precision
            integer.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="subtrahend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToBytes(System.Boolean)">
            <summary>Returns a byte array of this integer's value. The
            byte array will take the number's two' s-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ),
            using the fewest bytes necessary to store its value unambiguously.
            If this value is negative, the bits that appear beyond the most
            significant bit of the number will be all ones. The resulting byte
            array can be passed to the <c>FromBytes()</c> method (with the same
            byte order) to reconstruct this integer's value.</summary><param name="littleEndian">If true, the byte order is
            little-endian, or least-significant-byte first. If false, the byte
            order is big-endian, or most-significant-byte first.</param><returns>A byte array. If this value is 0, returns a byte array
            with the single element 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt32Checked">
            <summary>Converts this object's value to a 32-bit signed integer,
            throwing an exception if it can't fit.</summary><returns>A 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This object's value is
            too big to fit a 32-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt32Unchecked">
            <summary>Converts this object's value to a 32-bit signed integer.
            If the value can't fit in a 32-bit integer, returns the lower 32
            bits of this object's two' s-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            (in which case the return value might have a different sign than
            this object's value).</summary><returns>A 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt64Checked">
            <summary>Converts this object's value to a 64-bit signed integer,
            throwing an exception if it can't fit.</summary><returns>A 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This object's value is
            too big to fit a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt64Unchecked">
            <summary>Converts this object's value to a 64-bit signed integer.
            If the value can't fit in a 64-bit integer, returns the lower 64
            bits of this object's two' s-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            (in which case the return value might have a different sign than
            this object's value).</summary><returns>A 64-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToRadixString(System.Int32)">
            <summary>Generates a string representing the value of this object,
            in the given radix.</summary><param name="radix">A radix from 2 through 36. For example, to
            generate a hexadecimal (base-16) string, specify 16. To generate a
            decimal (base-10) string, specify 10.</param><returns>A string representing the value of this object. If this
            value is 0, returns "0". If negative, the string will begin with a
            minus sign ("-", U+002D). Depending on the radix, the string will
            use the basic digits 0 to 9 (U+0030 to U+0039) and then the
            basic letters A to Z (U+0041 to U+005A). For example, 0-9 in
            radix 10, and 0-9, then A-F in radix 16.</returns><exception cref="T:System.ArgumentException">The parameter "index"
            is less than 0, "endIndex" is less than 0, or either is greater
            than the string's length, or "endIndex" is less than "index" ; or
            radix is less than 2 or greater than 36.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToString">
            <summary>Converts this object to a text string in base
            10.</summary><returns>A string representation of this object. If negative, the
            string will begin with a minus sign ("-", U+002D). The string will
            use the basic digits 0 to 9 (U+0030 to U+0039).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255).</summary><returns>This number's value as a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">This value is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToByteUnchecked">
            <summary>Converts this number to a byte (from 0 to 255), returning the least-significant bits of this number's two's-complement form.</summary><returns>This number, converted to a byte (from 0 to 255).</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>This number's value as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer.</summary><returns>This number's value as a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToInt16Unchecked">
            <summary>Converts this number to a 16-bit signed integer, returning the least-significant bits of this number's two's-complement form.</summary><returns>This number, converted to a 16-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>This number's value as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an
            arbitrary-precision integer.</summary><param name="ulongValue">The number to convert as a 64-bit unsigned
            integer.</param><returns>The value of <paramref name="ulongValue" /> as an
            arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Addition(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Adds two arbitrary-precision integer objects and returns the result.</summary><param name="bthis">The first operand.</param><param name="augend">The second operand.</param><returns>The sum of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bthis" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Subtracts two arbitrary-precision integer
            values.</summary><param name="bthis">An arbitrary-precision integer.</param><param name="subtrahend">Another arbitrary-precision
            integer.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bthis" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Multiplies an arbitrary-precision integer by the value of
            an arbitrary-precision integer.</summary><param name="operand1">The first operand.</param><param name="operand2">The second operand.</param><returns>The product of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="operand1" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Division(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Divides an arbitrary-precision integer by the value of an
            arbitrary-precision integer object.</summary><param name="dividend">The number that will be divided by the
            divisor.</param><param name="divisor">The number to divide by.</param><returns>The quotient of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Finds the remainder that results when an
            arbitrary-precision integer is divided by the value of another
            arbitrary-precision integer.</summary><param name="dividend">The first operand.</param><param name="divisor">The number to divide by.</param><returns>The remainder of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="dividend" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Returns an arbitrary-precision integer with the bits
            shifted to the left by a number of bits. A value of 1 doubles this
            value, a value of 2 multiplies it by 4, a value of 3 by 8, a value
            of 4 by 16, and so on.</summary><param name="bthis">The arbitrary-precision integer to shift left.</param><param name="bitCount">The number of bits to shift. Can be
            negative, in which case this is the same as shiftRight with the
            absolute value of this parameter.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bthis" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Calculates the remainder when an arbitrary-precision
            integer raised to a certain power is divided by another
            arbitrary-precision integer.</summary><param name="bigintValue">The starting operand.</param><param name="pow">The power to raise this integer by.</param><param name="mod">The integer to divide the raised number by.</param><returns>The value ( <paramref name="bigintValue" /> ^ <paramref name="pow" /> )% <paramref name="mod" />.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigintValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Shifts the bits of an arbitrary-precision integer to the
            right.</summary><param name="bthis">Another arbitrary-precision integer.</param><param name="smallValue">The parameter <paramref name="smallValue" /> is a 32-bit signed integer.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bthis" /> is null.</exception><remarks>For this operation, the arbitrary-precision integer is
            treated as a two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ).
            Thus, for negative values, the arbitrary-precision integer is
            sign-extended.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)">
            <summary>Negates an arbitrary-precision integer.</summary><param name="bigValue">An arbitrary-precision integer to
            negate.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer.</summary><returns>This number's value as a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is outside
            the range of a 64-bit signed integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt64Unchecked">
            <summary>Converts this number to a 64-bit signed integer, returning
            the least-significant bits of this number's two' s-complement
            form.</summary><returns>This number, converted to a 64-bit signed
            integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is less
            than another arbitrary-precision integer.</summary><param name="thisValue">The first arbitrary-precision
            integer.</param><param name="otherValue">The second arbitrary-precision
            integer.</param><returns><c>true</c> if <paramref name="thisValue" /> is less than
            <paramref name="otherValue" /> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is less
            than or equal to another arbitrary-precision integer.</summary><param name="thisValue">The first arbitrary-precision
            integer.</param><param name="otherValue">The second arbitrary-precision
            integer.</param><returns><c>true</c> if <paramref name="thisValue" /> is up to
            <paramref name="otherValue" /> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer is
            greater than another arbitrary-precision integer.</summary><param name="thisValue">The first arbitrary-precision
            integer.</param><param name="otherValue">The second arbitrary-precision
            integer.</param><returns><c>true</c> if <paramref name="thisValue" /> is greater
            than <paramref name="otherValue" /> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Determines whether an arbitrary-precision integer value is
            greater than another arbitrary-precision integer.</summary><param name="thisValue">The first arbitrary-precision
            integer.</param><param name="otherValue">The second arbitrary-precision
            integer.</param><returns><c>true</c> if <paramref name="thisValue" /> is at least
            <paramref name="otherValue" /> ; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with every bit
            flipped.</summary><param name="thisValue">The operand as an arbitrary-precision integer.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="thisValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_BitwiseAnd(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an AND operation between two arbitrary-precision
            integer values.</summary><param name="thisValue">The first operand.</param><param name="otherValue">The second operand.</param><returns>The result of the operation.</returns><exception cref="T:System.ArgumentNullException">The parameter "a"
            or "b" is null.</exception><remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_BitwiseOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an OR operation between two arbitrary-precision
            integer instances.</summary><param name="thisValue">An arbitrary-precision integer.</param><param name="otherValue">Another arbitrary-precision integer.</param><returns>The result of the operation.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "first" or "second" is null.</exception><remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_ExclusiveOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Finds the exclusive "or" of two arbitrary-precision
            integer objects.
            <para>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</para></summary><param name="a">The first arbitrary-precision integer.</param><param name="b">The second arbitrary-precision integer.</param><returns>An arbitrary-precision integer in which each bit is set if
            it's set in one input integer but not the other.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="a" /> or <paramref name="b" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.GetBits(System.Int32,System.Int32)">
            <summary>Retrieves bits from this integer's two' s-complement
            form.</summary><param name="index">Zero-based index of the first bit to retrieve,
            where 0 is the least-significant bit of the number.</param><param name="numberBits">The number of bits to retrieve, starting
            with the first. Must be from 0 through 64.</param><returns>A 64-bit signed integer containing the bits from this
            integer's two' s-complement form. The least significant bit is the
            first bit, and any unused bits are set to 0.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger@)">
            <summary>Divides one arbitrary-precision integer by another, and
            returns the quotient and sets an output parameter to the
            remainder.</summary><param name="dividend">The arbitrary-precision integer to be
            divided.</param><param name="divisor">The arbitrary-precision integer to divide by.</param><param name="remainder">An arbitrary-precision integer.
            (4).</param><returns>An array of two arbitrary-precision integers: the first is
            the quotient, and the second is the remainder.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="dividend" /> or <paramref name="divisor" /> is
            null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Equals(PeterO.Numbers.EInteger)">
            <summary>Determines whether this object and another object are
            equal.</summary><param name="other">Another arbitrary-precision integer.</param><returns><c>true</c> if this object and another object are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Not(PeterO.Numbers.EInteger)">
            <summary>Returns an arbitrary-precision integer with every bit
            flipped.</summary><param name="valueA">The operand as an arbitrary-precision integer.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="valueA" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an AND operation between two arbitrary-precision
            integer values.</summary><param name="a">The first arbitrary-precision integer.</param><param name="b">The second arbitrary-precision integer.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="a" /> or <paramref name="b" /> is null.</exception><remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Does an OR operation between two arbitrary-precision
            integer instances.</summary><param name="first">The first operand.</param><param name="second">The second operand.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="first" /> or <paramref name="second" /> is
            null.</exception><remarks>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</remarks>
        </member>
        <member name="M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Finds the exclusive "or" of two arbitrary-precision
            integer objects.
            <para>Each arbitrary-precision integer is treated as a
            two's-complement form (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> )
            for the purposes of this operator.</para></summary><param name="a">The first arbitrary-precision integer.</param><param name="b">The second arbitrary-precision integer.</param><returns>An arbitrary-precision integer in which each bit is set if
            it's set in one input integer but not the other.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="a" /> or <paramref name="b" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Byte">
            <summary>Converts an arbitrary-precision integer to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255).</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>The value of <paramref name="inputByte" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer.</summary><returns>This number's value as an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToSByteUnchecked">
            <summary>Converts this number to an 8-bit signed integer, returning the least-significant bits of this number's two's-complement form.</summary><returns>This number, converted to an 8-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>This number's value as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte">
            <summary>Converts an arbitrary-precision integer to an 8-bit signed integer
            if it can fit in an 8-bit signed integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>The value of <paramref name="inputSByte" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int16">
            <summary>Converts an arbitrary-precision integer to a 16-bit signed integer
            if it can fit in a 16-bit signed integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>The value of <paramref name="inputInt16" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer.</summary><returns>This number's value as a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt16Unchecked">
            <summary>Converts this number to a 16-bit unsigned integer, returning the least-significant bits of this number's two's-complement form.</summary><returns>This number, converted to a 16-bit unsigned integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16">
            <summary>Converts an arbitrary-precision integer to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt16" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32">
            <summary>Converts an arbitrary-precision integer to a 32-bit signed integer
            if it can fit in a 32-bit signed integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputInt32" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.ToUInt32Unchecked">
            <summary>Converts this number to a 32-bit signed integer, returning the least-significant bits of this number's two's-complement form.</summary><returns>This number, converted to a 32-bit signed integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32">
            <summary>Converts an arbitrary-precision integer to a 32-bit signed integer
            if it can fit in a 32-bit signed integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputUInt32" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64">
            <summary>Converts an arbitrary-precision integer to a 64-bit signed integer
            if it can fit in a 64-bit signed integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision integer.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>The value of <paramref name="inputInt64" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64">
            <summary>Converts an arbitrary-precision integer to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer.</summary><param name="input">The number to convert as an arbitrary-precision integer.</param><returns>The value of <paramref name="input" /> as a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" />
            is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt64" /> as an arbitrary-precision integer.</returns>
        </member>
        <member name="T:PeterO.Numbers.ERational">
            <summary>Represents an arbitrary-precision rational number. This
            class can't be inherited. (The "E" stands for "extended", meaning
            that instances of this class can be values other than numbers
            proper, such as infinity and not-a-number.)
            <para><b>Thread safety:</b> Instances of this class are immutable,
            so they are inherently safe for use by multiple threads. Multiple
            instances of this object with the same properties are
            interchangeable, so they should not be compared using the "=="
            operator (which might only check if each side of the operator is
            the same instance).</para></summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.NaN">
            <summary>A not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.NegativeInfinity">
            <summary>Negative infinity, less than any other number.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.NegativeZero">
            <summary>A rational number for negative zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.One">
            <summary>The rational number one.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.PositiveInfinity">
            <summary>Positive infinity, greater than any other
            number.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.SignalingNaN">
            <summary>A signaling not-a-number value.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.Ten">
            <summary>The rational number ten.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERational.Zero">
            <summary>A rational number for zero.</summary>
        </member>
        <member name="M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Initializes a new instance of the <see cref="T:PeterO.Numbers.ERational" /> class.</summary><param name="numerator">The numerator.</param><param name="denominator">The denominator.</param><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="numerator" /> or <paramref name="denominator" /> is
            null.</exception><exception cref="T:System.ArgumentException">The denominator is
            zero.</exception>
        </member>
        <member name="P:PeterO.Numbers.ERational.Denominator">
            <summary>Gets this object's denominator.</summary><value>This object's denominator.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsFinite">
            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary><value><c>true</c> if this object is finite (not infinity or
            not-a-number (NaN)); otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsNegative">
            <summary>Gets a value indicating whether this object's value is
            negative (including negative zero).</summary><value><c>true</c> if this object's value is negative; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.IsZero">
            <summary>Gets a value indicating whether this object's value equals
            0.</summary><value><c>true</c> if this object's value equals 0; otherwise,
            . <c>false</c>.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.Numerator">
            <summary>Gets this object's numerator.</summary><value>This object's numerator. If this object is a
            not-a-number value, returns the diagnostic information (which will
            be negative if this object is negative).</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.Sign">
            <summary>Gets the sign of this rational number.</summary><value>Zero if this value is zero or negative zero; -1 if this
            value is less than 0; and 1 if this value is greater than
            0.</value>
        </member>
        <member name="P:PeterO.Numbers.ERational.UnsignedNumerator">
            <summary>Gets this object's numerator with the sign
            removed.</summary><value>This object's numerator. If this object is a
            not-a-number value, returns the diagnostic information.</value>
        </member>
        <member name="M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)">
            <summary>Creates a rational number with the given numerator and
            denominator.</summary><param name="numeratorSmall">The numerator.</param><param name="denominatorSmall">The denominator.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentException">The denominator is
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates a rational number with the given numerator and
            denominator.</summary><param name="numerator">The numerator.</param><param name="denominator">The denominator.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentException">The denominator is
            zero.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)">
            <summary>Creates a not-a-number arbitrary-precision rational
            number.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="diag" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)">
            <summary>Creates a not-a-number arbitrary-precision rational
            number.</summary><param name="diag">A number to use as diagnostic information
            associated with this object. If none is needed, should be
            zero.</param><param name="signaling">Whether the return value will be signaling
            (true) or quiet (false).</param><param name="negative">Whether the return value is
            negative.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="diag" /> is null.</exception><exception cref="T:System.ArgumentException">The parameter
            <paramref name="diag" /> is less than 0.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromDouble(System.Double)">
            <summary>Converts a 64-bit floating-point number to a rational
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the number to a string.</summary><param name="flt">The parameter <paramref name="flt" /> is a 64-bit floating-point number.</param><returns>A rational number with the same value as <paramref name="flt" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)">
            <summary>Converts an arbitrary-precision decimal number to a
            rational number.</summary><param name="ef">The number to convert as an arbitrary-precision decimal number.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="ef" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary float to a
            rational number.</summary><param name="ef">The number to convert as an arbitrary-precision binary float.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="ef" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)">
            <summary>Converts an arbitrary-precision decimal number to a
            rational number.</summary><param name="ef">The number to convert as an arbitrary-precision decimal number.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="ef" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)">
            <summary>Converts an arbitrary-precision binary float to a
            rational number.</summary><param name="ef">The number to convert as an arbitrary-precision binary float.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="ef" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)">
            <summary>Converts an arbitrary-precision integer to a rational
            number.</summary><param name="bigint">The number to convert as an arbitrary-precision integer.</param><returns>The exact value of the integer as a rational
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromSingle(System.Single)">
            <summary>Converts a 32-bit binary floating-point number to a rational
            number. This method computes the exact value of the floating point
            number, not an approximation, as is often the case by converting
            the number to a string.</summary><param name="flt">The parameter <paramref name="flt" /> is a 32-bit binary floating-point number.</param><returns>A rational number with the same value as <paramref name="flt" />.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.String)">
            <summary>Creates a rational number from a text string that
            represents a number. See <c>FromString(String, int, int)</c> for
            more information.</summary><param name="str">A string that represents a number.</param><returns>An arbitrary-precision rational number with the same value
            as the given string.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Creates a rational number from a text string that represents
            a number.</para>
            <para>The format of the string generally consists of:</para>
            <list type="">
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>The numerator in the form of one or more digits.</item>
            <item>Optionally, "/" followed by the denominator in the form of
            one or more digits. If a denominator is not given, it's equal to
            1.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN" /"-NaN") followed by any number of digits,
            or signaling NaN ("sNaN" /"-sNaN") followed by any number of
            digits, all in any combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is
            not allowed to contain white space characters, including
            spaces.</para></summary><param name="str">A text string, a portion of which represents a
            number.</param><param name="offset">A zero-based index that identifies the start
            of the number.</param><param name="length">The length of the number within the
            string.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="str" /> is null.</exception><exception cref="T:System.FormatException">The parameter <paramref name="str" /> is not a correctly formatted number
            string.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)">
            <summary>Compares the absolute values of this object and another
            object, imposing a total ordering on all possible values (ignoring
            their signs). In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            denominator has a greater "absolute value".</item>
            <item>Negative zero and positive zero are considered equal.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item></list></summary><param name="other">An arbitrary-precision rational number to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)">
            <summary>Compares the values of this object and another object,
            imposing a total ordering on all possible values. In this method:
            <list>
            <item>For objects with the same value, the one with the higher
            denominator has a greater "absolute value".</item>
            <item>Negative zero is less than positive zero.</item>
            <item>Quiet NaN has a higher "absolute value" than signaling NaN.
            If both objects are quiet NaN or both are signaling NaN, the one
            with the higher diagnostic information has a greater "absolute
            value".</item>
            <item>NaN has a higher "absolute value" than infinity.</item>
            <item>Infinity has a higher "absolute value" than any finite
            number.</item>
            <item>Negative numbers are less than positive
            numbers.</item></list></summary><param name="other">An arbitrary-precision rational number to
            compare with this one.</param><returns>The number 0 if both objects have the same value, or -1 if
            this object is less than the other value, or 1 if this object is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Abs">
            <summary>Returns the absolute value of this rational number, that is, a number with the same value as this one but as a nonnegative number.</summary><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)">
            <summary>Adds two rational numbers.</summary><param name="otherValue">Another arbitrary-precision rational
            number.</param><returns>The sum of the two numbers. Returns not-a-number (NaN) if
            either operand is NaN.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)">
            <summary>Compares an arbitrary-precision rational number with this
            instance.</summary><param name="other">An arbitrary-precision rational number.</param><returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)">
            <summary>Compares an arbitrary-precision binary float with this
            instance.</summary><param name="other">An arbitrary-precision binary float.</param><returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)">
            <summary>Compares an arbitrary-precision decimal number with this
            instance.</summary><param name="other">An arbitrary-precision decimal number.</param><returns>Zero if the values are equal; a negative number if this
            instance is less, or a positive number if this instance is
            greater.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)">
            <summary>Returns a number with the same value as this one, but
            copying the sign (positive or negative) of another
            number.</summary><param name="other">A number whose sign will be copied.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="other" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)">
            <summary>Divides this instance by the value of an
            arbitrary-precision rational number object.</summary><param name="otherValue">An arbitrary-precision rational
            number.</param><returns>The quotient of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Equals(System.Object)">
            <summary>Determines whether this object's numerator,
            denominator, and properties are equal to those of another
            object and that other object is an arbitrary-precision
            rational number. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="obj">The parameter <paramref name="obj" /> is an arbitrary object.</param><returns><c>true</c> if the objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)">
            <summary>Determines whether this object's numerator,
            denominator, and properties are equal to those of another
            object. Not-a-number values are considered equal if the rest of their
            properties are equal.</summary><param name="other">An arbitrary-precision rational
            number to compare to.</param><returns>Either <c>true</c> or <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.GetHashCode">
            <summary>Returns the hash code for this instance.  No application or process IDs are used in the hash code calculation.</summary><returns>A 32-bit hash code.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsInfinity">
            <summary>Gets a value indicating whether this object's value is
            infinity.</summary><returns><c>true</c> if this object's value is infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsNaN">
            <summary>Returns whether this object is a not-a-number
            value.</summary><returns><c>true</c> if this object is a not-a-number value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsNegativeInfinity">
            <summary>Returns whether this object is negative
            infinity.</summary><returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsPositiveInfinity">
            <summary>Returns whether this object is positive
            infinity.</summary><returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsQuietNaN">
            <summary>Returns whether this object is a quiet not-a-number
            value.</summary><returns><c>true</c> if this object is a quiet not-a-number value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.IsSignalingNaN">
            <summary>Returns whether this object is a signaling not-a-number
            value (which causes an error if the value is passed to any
            arithmetic operation in this class).</summary><returns><c>true</c> if this object is a signaling not-a-number
            value (which causes an error if the value is passed to any
            arithmetic operation in this class); otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)">
            <summary>Multiplies this instance by the value of an
            arbitrary-precision rational number.</summary><param name="otherValue">An arbitrary-precision rational
            number.</param><returns>The product of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Negate">
            <summary>Returns a rational number with the same value as this one but with the sign
            reversed.</summary><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)">
            <summary>Finds the remainder that results when this instance is
            divided by the value of an arbitrary-precision rational
            number.</summary><param name="otherValue">An arbitrary-precision rational
            number.</param><returns>The remainder of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)">
            <summary>Subtracts an arbitrary-precision rational number from this
            instance.</summary><param name="otherValue">An arbitrary-precision rational
            number.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="otherValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToDouble">
            <summary>Converts this value to a 64-bit floating-point number. The
            half-even rounding mode is used.</summary><returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEInteger">
            <summary>Converts this value to an arbitrary-precision integer. Any
            fractional part in this value will be discarded when converting to
            an arbitrary-precision integer.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEIntegerExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value is an exact integer.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEIntegerIfExact">
            <summary>Converts this value to an arbitrary-precision integer,
            checking whether the value is an exact integer.</summary><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception><exception cref="T:System.ArithmeticException">This object's value
            is not an exact integer.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimal">
            <summary>Converts this rational number to a decimal
            number.</summary><returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            decimal expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a decimal number and
            rounds the result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param><returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a decimal number, but if
            the result would have a nonterminating decimal expansion, rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            decimal expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param><returns>The exact value of the rational number if possible;
            otherwise,the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimal">
            <summary>Converts this rational number to a decimal
            number.</summary><returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            decimal expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a decimal number and
            rounds the result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param><returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a decimal number, but if
            the result would have a nonterminating decimal expansion, rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            decimal expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param><returns>The exact value of the rational number if possible;
            otherwise,the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating decimal
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloat">
            <summary>Converts this rational number to a binary float.</summary><returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            binary expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary float and rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param><returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary float, but if
            the result would have a nonterminating binary expansion, rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            binary expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param><returns>The exact value of the rational number if possible;
            otherwise,the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloat">
            <summary>Converts this rational number to a binary float.</summary><returns>The exact value of the rational number, or not-a-number
            (NaN) if the result can't be exact because it has a nonterminating
            binary expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary float and rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. If HasFlags
            of the context is true, will also store the flags resulting from
            the operation (the flags are in addition to the pre-existing
            flags). Can be null, in which case the precision is unlimited and
            no rounding is needed.</param><returns>The value of the rational number, rounded to the given
            precision. Returns not-a-number (NaN) if the context is null and
            the result can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)">
            <summary>Converts this rational number to a binary float, but if
            the result would have a nonterminating binary expansion, rounds
            that result to the given precision.</summary><param name="ctx">An arithmetic context object to control the
            precision, rounding, and exponent range of the result. This context
            will be used only if the exact result would have a nonterminating
            binary expansion. If HasFlags of the context is true, will also
            store the flags resulting from the operation (the flags are in
            addition to the pre-existing flags). Can be null, in which case the
            precision is unlimited and no rounding is needed.</param><returns>The exact value of the rational number if possible;
            otherwise,the rounded version of the result if a context is given.
            Returns not-a-number (NaN) if the context is null and the result
            can't be exact because it has a nonterminating binary
            expansion.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSingle">
            <summary>Converts this value to a 32-bit binary floating-point number. The
            half-even rounding mode is used.</summary><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToString">
            <summary>Converts this object to a text string.</summary><returns>A string representation of this object. If this object's
            value is infinity or not-a-number, the result is the analogous
            return value of the <c>EDecimal.ToString</c> method. Otherwise, the
            return value has the following form:
            <c>[-]numerator/denominator</c>.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteChecked">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><returns>This number's value, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a byte (from 0 to 255).</summary><returns>This number, converted to a byte (from 0 to 255).  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToByteIfExact">
            <summary>Converts this number's value to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) without rounding to a different numerical value.</summary><returns>This number's value as a byte (from 0 to 255).</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromByte(System.Byte)">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16Checked">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit signed integer.</summary><returns>This number, converted to a 16-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt16IfExact">
            <summary>Converts this number's value to a 16-bit signed integer
            if it can fit in a 16-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt16(System.Int16)">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt32(System.Int32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64Checked">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit signed integer.</summary><returns>This number, converted to a 64-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToInt64IfExact">
            <summary>Converts this number's value to a 64-bit signed integer
            if it can fit in a 64-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromInt64(System.Int64)">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision integer to an arbitrary-precision rational number.</summary><param name="eint">An arbitrary-precision integer.</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision decimal floating-point number to an arbitrary-precision rational number.</summary><param name="eint">The parameter <paramref name="eint" /> is an arbitrary-precision decimal floating-point number.</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational">
            <summary>Converts an arbitrary-precision binary float to an arbitrary-precision rational number.</summary><param name="eint">An arbitrary-precision binary float.</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)">
            <summary>Converts a <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal) to a rational number.</summary><param name="eint">The number to convert as a <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational">
            <summary>Converts a <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal). to an arbitrary-precision rational number.</summary><param name="eint">A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit binary floating-point number to a rational number.</summary><param name="eint">The parameter <paramref name="eint" /> is a 32-bit binary floating-point number.</param><returns>The value of <paramref name="eint" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit floating-point number to an arbitrary-precision rational number.</summary><param name="eint">The parameter <paramref name="eint" /> is a 64-bit floating-point number.</param><returns>An arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Adds two rational numbers.</summary><param name="bthis">The first operand.</param><param name="augend">The second operand.</param><returns>The sum of the two numbers. Returns not-a-number (NaN) if
            either operand is NaN.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "otherValue" is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Subtracts an arbitrary-precision rational number from this
            instance.</summary><param name="bthis">The first operand.</param><param name="subtrahend">The second operand.</param><returns>The difference of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "otherValue" is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Multiplies this instance by the value of an
            arbitrary-precision rational number.</summary><param name="operand1">The first operand.</param><param name="operand2">The second operand.</param><returns>The product of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "otherValue" is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Divides an arbitrary-precision rational number by the value of another
            arbitrary-precision rational number object.</summary><param name="dividend">An arbitrary-precision rational number serving as the dividend.</param><param name="divisor">An arbitrary-precision rational number serving as the divisor.</param><returns>The quotient of the two objects.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "otherValue" is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
            <summary>Finds the remainder that results when this instance is
            divided by the value of an arbitrary-precision rational
            number.</summary><param name="dividend">The dividend.</param><param name="divisor">The divisor.</param><returns>The remainder of the two numbers.</returns><exception cref="T:System.ArgumentNullException">The parameter
            "otherValue" is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)">
            <summary>Returns an arbitrary-precision rational number with the same value
as the given one but with its sign reversed.</summary><param name="bigValue">An arbitrary-precision rational number to negate.</param><returns>An arbitrary-precision rational number.</returns><exception cref="T:System.ArgumentNullException">The parameter
            <paramref name="bigValue" /> is null.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToDecimal">
            <summary>Converts this value to a <c>decimal</c> under
the Common Language Infrastructure (usually a .NET Framework decimal).  Currently,
converts this value to the precision and range of a .NET Framework decimal.</summary><returns>A <c>decimal</c> under
the Common Language Infrastructure (usually a .NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal">
            <summary>Converts an arbitrary-precision rational number to a <c>decimal</c> under the Common Language Infrastructure (see
            <see cref="T:PeterO.Numbers.EDecimal">"Forms of numbers"</see> ).</summary><param name="extendedNumber">The number to convert as an arbitrary-precision rational number.</param><returns>A <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework decimal).</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger">
            <summary>Converts an arbitrary-precision rational number to an arbitrary-precision integer. Any
            fractional part in the value will be discarded when converting to
            an arbitrary-precision integer.</summary><param name="bigValue">An arbitrary-precision rational number.</param><returns>An arbitrary-precision integer.</returns><exception cref="T:System.OverflowException">This object's value is
            infinity or not-a-number (NaN).</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double">
            <summary>Converts an arbitrary-precision rational number  to a 64-bit floating-point number. The
            half-even rounding mode is used.</summary><param name="bigValue">The number to convert as an arbitrary-precision rational number.</param><returns>The closest 64-bit floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single">
            <summary>Converts an arbitrary-precision rational number to a 32-bit binary floating-point number. The
            half-even rounding mode is used.</summary><param name="bigValue">The number to convert as an arbitrary-precision rational number.</param><returns>The closest 32-bit binary floating-point number to this value.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 32-bit floating point
            number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte">
            <summary>Converts an arbitrary-precision rational number to a byte (from 0 to 255)
            if it can fit in a byte (from 0 to 255) after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a byte (from 0 to 255).</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 255.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational">
            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.</summary><param name="inputByte">The number to convert as a byte (from 0 to 255).</param><returns>The value of <paramref name="inputByte" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteChecked">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteUnchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as an 8-bit signed integer.</summary><returns>This number, converted to an 8-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToSByteIfExact">
            <summary>Converts this number's value to an 8-bit signed integer
            if it can fit in an 8-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as an 8-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromSByte(System.SByte)">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte">
            <summary>Converts an arbitrary-precision rational number to an 8-bit signed integer
            if it can fit in an 8-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to an 8-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -128 or greater than 127.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational">
            <summary>Converts an 8-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputSByte">The number to convert as an 8-bit signed integer.</param><returns>The value of <paramref name="inputSByte" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16">
            <summary>Converts an arbitrary-precision rational number to a 16-bit signed integer
            if it can fit in a 16-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -32768 or greater than 32767.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational">
            <summary>Converts a 16-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt16">The number to convert as a 16-bit signed integer.</param><returns>The value of <paramref name="inputInt16" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16Checked">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 16-bit unsigned integer.</summary><returns>This number, converted to a 16-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt16IfExact">
            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 16-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16">
            <summary>Converts an arbitrary-precision rational number to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 16-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 65535.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational">
            <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational number.</summary><param name="inputUInt16">The number to convert as a 16-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt16" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32">
            <summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -2147483648 or greater than 2147483647.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputInt32" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32Checked">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><returns>This number's value, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 32-bit signed integer.</summary><returns>This number, converted to a 32-bit signed integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt32IfExact">
            <summary>Converts this number's value to a 32-bit signed integer
            if it can fit in a 32-bit signed integer without rounding to a different numerical value.</summary><returns>This number's value as a 32-bit signed integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32">
            <summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
            if it can fit in a 32-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 32-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 4294967295.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational">
            <summary>Converts a 32-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputUInt32">The number to convert as a 32-bit signed integer.</param><returns>The value of <paramref name="inputUInt32" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64">
            <summary>Converts an arbitrary-precision rational number to a 64-bit signed integer
            if it can fit in a 64-bit signed integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit signed integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than -9223372036854775808 or greater than 9223372036854775807.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit signed integer to an arbitrary-precision rational number.</summary><param name="inputInt64">The number to convert as a 64-bit signed integer.</param><returns>The value of <paramref name="inputInt64" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64Checked">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><returns>This number's value, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">This value is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64Unchecked">
            <summary>Truncates this number's value to an integer
            and returns the least-significant bits of its two's-complement form as a 64-bit unsigned integer.</summary><returns>This number, converted to a 64-bit unsigned integer.  Returns 0 if this
            value is infinity or not-a-number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.ToUInt64IfExact">
            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a different numerical value.</summary><returns>This number's value as a 64-bit unsigned integer.</returns><exception cref="T:System.ArithmeticException">This value is infinity or not-a-number, is not an exact integer, or is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>This number's value as an arbitrary-precision rational number.</returns>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64">
            <summary>Converts an arbitrary-precision rational number to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after truncating to an integer.</summary><param name="input">The number to convert as an arbitrary-precision rational number.</param><returns>The value of <paramref name="input" />, truncated to a 64-bit unsigned integer.</returns><exception cref="T:System.OverflowException">The parameter <paramref name="input" /> is infinity or not-a-number,
            or the truncated integer is less than 0 or greater than 18446744073709551615.</exception>
        </member>
        <member name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational">
            <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational number.</summary><param name="inputUInt64">The number to convert as a 64-bit unsigned integer.</param><returns>The value of <paramref name="inputUInt64" /> as an arbitrary-precision rational number.</returns>
        </member>
        <member name="T:PeterO.Numbers.ERounding">
            <summary>Specifies the mode to use when "shortening"
            numbers that otherwise can't fit a given number of digits, so
            that the shortened number has about the same value. This
            "shortening" is known as rounding. (The "E" stands for
            "extended", and has this prefix to group it with the other classes
            common to this library, particularly EDecimal, EFloat, and
            ERational.).</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.None">
            <summary>Indicates that rounding will not be used. If rounding is
            required, the rounding operation will report an error.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Up">
            <summary>If there is a fractional part, the number is rounded to
            the closest representable number away from zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Down">
            <summary>The fractional part is discarded (the number is
            truncated).</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfUp">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number away from zero. This is the most familiar rounding mode for
            many people.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfDown">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, it is discarded.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.HalfEven">
            <summary>Rounded to the nearest number; if the fractional part is
            exactly half, the number is rounded to the closest representable
            number that is even. This is sometimes also known as
            "banker's rounding".</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Ceiling">
            <summary>If there is a fractional part, the number is rounded to
            the highest representable number that's closest to
            it.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Floor">
            <summary>If there is a fractional part, the number is rounded to
            the lowest representable number that's closest to
            it.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.Odd">
            <summary>If there is a fractional part and the whole number part is
            even, the number is rounded to the closest representable odd number
            away from zero.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.ZeroFiveUp">
            <summary>If there is a fractional part and if the last digit before
            rounding is 0 or half the radix, the number is rounded to the
            closest representable number away from zero; otherwise the
            fractional part is discarded. In overflow, the fractional part is
            always discarded.</summary>
        </member>
        <member name="F:PeterO.Numbers.ERounding.OddOrZeroFiveUp">
            <summary>For binary floating point numbers, this is the same as
            Odd. For other bases (including decimal numbers), this is the same
            as ZeroFiveUp. This rounding mode is useful for rounding
            intermediate results at a slightly higher precision (at least 2
            bits more for binary) than the final precision.</summary>
        </member>
        <member name="T:PeterO.Numbers.ETrapException">
            <summary>Exception thrown for arithmetic trap errors. (The "E"
            stands for "extended", and has this prefix to group it with the
            other classes common to this library, particularly EDecimal,
            EFloat, and ERational.).</summary>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Context">
            <summary>Gets the arithmetic context used during the operation that
            triggered the trap. May be null.</summary><value>The arithmetic context used during the operation that
            triggered the trap. May be null.</value>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Result">
            <summary>Gets the defined result of the operation that caused the
            trap.</summary><value>The defined result of the operation that caused the
            trap.</value>
        </member>
        <member name="P:PeterO.Numbers.ETrapException.Error">
            <summary>Gets the flag that specifies the kind of error
            (EContext.FlagXXX). This will only be one flag, such as
            <c>FlagInexact</c> or FlagSubnormal.</summary><value>The flag that specifies the kind of error
            (EContext.FlagXXX). This will only be one flag, such as.
            <c>FlagInexact</c> or FlagSubnormal.</value>
        </member>
        <member name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)">
            <summary>Initializes a new instance of the <see cref="T:PeterO.Numbers.ETrapException" /> class.</summary><param name="flag">A flag that specifies the kind of error (
            <c>EContext.FlagXXYY</c> ). This will only be one flag, such as
            <c>FlagInexact</c> or FlagSubnormal.</param><param name="ctx">A context object for arbitrary-precision
            arithmetic settings.</param><param name="result">The parameter <paramref name="result" /> is an arbitrary object.</param>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Multiply(System.Int32)">
            <summary>This is an internal API.</summary><param name="val">The parameter <paramref name="val" /> is an internal value.</param><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Negate">
            <summary>This is an internal API.</summary><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)">
            <summary>This is an internal API.</summary><param name="val">The parameter <paramref name="val" /> is an internal value.</param><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)">
            <summary>This is an internal API.</summary><param name="val">The parameter <paramref name="val" /> is an internal value.</param><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)">
            <summary>This is an internal API.</summary><param name="bigintVal">The parameter <paramref name="bigintVal" />
            is an internal value.</param><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)">
            <summary>This is an internal API.</summary><param name="bigintVal">The parameter <paramref name="bigintVal" />
            is an internal value.</param><returns>A FastInteger object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastInteger.ToString">
            <summary>This is an internal API.</summary><returns>A text string.</returns>
        </member>
        <member name="P:PeterO.Numbers.FastInteger.Sign">
            <summary>Gets an internal value.</summary><value>an internal value.</value>
        </member>
        <member name="M:PeterO.Numbers.FastIntegerFixed.Negate">
            <summary>This is an internal API.</summary><returns>A FastIntegerFixed object.</returns>
        </member>
        <member name="M:PeterO.Numbers.FastIntegerFixed.ToString">
            <summary>This is an internal API.</summary><returns>A text string.</returns>
        </member>
        <member name="T:PeterO.Numbers.IShiftAccumulator">
            <summary>Common interface for classes that shift a number of digits
            and record information on whether a non-zero digit was discarded
            this way.</summary>
        </member>
        <member name="T:PeterO.Numbers.RadixMath`1">
            <summary>Encapsulates radix-independent arithmetic.</summary><typeparam name="T">Data type for a numeric value in a particular
            radix.</typeparam>
        </member>
    </members>
</doc>
